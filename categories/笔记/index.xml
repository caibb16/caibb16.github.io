<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>笔记 on caibb16</title>
        <link>https://caibb16.github.io/categories/%E7%AC%94%E8%AE%B0/</link>
        <description>Recent content in 笔记 on caibb16</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>caibb16</copyright>
        <lastBuildDate>Mon, 29 Dec 2025 12:32:33 +0800</lastBuildDate><atom:link href="https://caibb16.github.io/categories/%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>数值分析笔记</title>
        <link>https://caibb16.github.io/p/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Mon, 29 Dec 2025 12:32:33 +0800</pubDate>
        
        <guid>https://caibb16.github.io/p/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h2 id=&#34;绪论&#34;&gt;绪论
&lt;/h2&gt;&lt;h3 id=&#34;误差&#34;&gt;误差
&lt;/h3&gt;&lt;p&gt;绝对误差： $e = x^* - x$&lt;br&gt;
$|e| = |x^* - x| \leq \varepsilon$，$\varepsilon$ 为近似值 $x$ 的绝对误差限&lt;br&gt;
相对误差： $e_r = \frac{e}{x}$&lt;br&gt;
$|e_r| = \frac{|e|}{|x|} \leq \varepsilon_r$，$\varepsilon_r$ 为近似值 $x$ 的相对误差限&lt;br&gt;
有效数：如果 $|x^* - x| \leq \frac{1}{2} \times 10^{-t}$，则近似值 $x$ 的有效数字为 $n$ 位，$n = t + $ 小数点前的有效数字位数&lt;br&gt;
数据误差对函数的影响：&lt;br&gt;
若 $y = f(x_1, x_2)$，则误差传播可用泰勒展开近似表示，即&lt;/p&gt;
$$
e(y) \approx \frac{\partial f(x_1, x_2)}{\partial x_1} e(x_1) + \frac{\partial f(x_1, x_2)}{\partial x_2} e(x_2)
$$$$
e_r(y) = \frac{e(y)}{y} \approx \frac{\partial f}{\partial x_1} \frac{x_1}{f(x_1, x_2)} e_r(x_1) + \frac{\partial f}{\partial x_2} \frac{x_2}{f(x_1, x_2)} e_r(x_2)
$$&lt;p&gt;补充：
二元函数泰勒展开：&lt;/p&gt;
$$
f(x_1 + \Delta x_1, x_2 + \Delta x_2) = f(x_1, x_2) + \frac{\partial f}{\partial x_1} \Delta x_1 + \frac{\partial f}{\partial x_2} \Delta x_2 \newline + \frac{1}{2!} \left( \frac{\partial^2 f}{\partial x_1^2} (\Delta x_1)^2 + 2 \frac{\partial^2 f}{\partial x_1 \partial x_2} \Delta x_1 \Delta x_2 + \frac{\partial^2 f}{\partial x_2^2} (\Delta x_2)^2 \right) + \cdots
$$&lt;h2 id=&#34;方程求根-fx--0&#34;&gt;方程求根 $f(x) = 0$
&lt;/h2&gt;&lt;h3 id=&#34;迭代法的收敛性&#34;&gt;迭代法的收敛性
&lt;/h3&gt;&lt;p&gt;设迭代格式为 $x_{k+1} = \varphi(x_k)$，若存在 $x^ *$ 使得 $x^ *= \varphi(x^ * )$，则 $x^ *$ 为方程 $f(x) = 0$ 的一个根。&lt;/p&gt;
&lt;p&gt;迭代法收敛定理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;设 $\varphi(x)$ 在 $[a, b]$ 上存在一阶连续导数，且满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对任意 $x \in [a, b]$，有 $\varphi(x) \in [a, b]$&lt;/li&gt;
&lt;li&gt;存在 $0 &amp;lt; L &amp;lt; 1$，使得对任意 $x \in [a, b]$，有 $\max\limits_{a \leq x \leq b} |\varphi&amp;rsquo;(x)| \leq L &amp;lt; 1$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;则&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$x = \varphi(x)$ 在 $[a, b]$ 上有唯一实根 $x^ *$&lt;/li&gt;
&lt;li&gt;对任意初值 $x_0 \in [a, b]$，迭代格式 $x_{k+1} = \varphi(x_k)$ 收敛于 $x^ *$，且有&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
$$
|x_k - x^*| \leq \frac{L}{1-L} |x_k - x_{k-1}|,\quad k = 1, 2, \cdots;
$$$$
|x_k - x^*| \leq \frac{L^k}{1-L} |x_1 - x_0|,\quad k = 1, 2, \cdots;
$$$$
\lim_{k \to \infty} \frac{x^* - x_{k+1}}{x^* - x_k} = \varphi&#39;(x^*)
$$&lt;ul&gt;
&lt;li&gt;设方程 $x = \varphi(x)$ 在区间 $[a, b]$ 上有根，且 $\min\limits_{a \leq x \leq b} |\varphi&amp;rsquo;(x)| \geq 1$，则对任意 $x_0 \in [a, b]$，且 $x_0 \neq x^*$，迭代格式 $x_{k+1} = \varphi(x_k)$ 发散。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;newton-迭代法&#34;&gt;Newton 迭代法
&lt;/h3&gt;&lt;p&gt;设 $f(x)$ 在区间 $[a, b]$ 上连续，且 $f(a) f(b) &amp;lt; 0$，则存在 \(x^* \in (a, b)\) 使得 $f(x^*) = 0$。
取初值 $x_0 \in [a, b]$，则迭代公式为&lt;/p&gt;
$$
x_{k+1} = x_k - \frac{f(x_k)}{f&#39;(x_k)}
$$&lt;h3 id=&#34;newton-迭代的局部收敛性&#34;&gt;Newton 迭代的局部收敛性
&lt;/h3&gt;&lt;p&gt;若 $\varphi(x)$ 在 \(x^*\) 附近的某个邻域内有 $p (\geq 1)$ 阶连续导数，且&lt;/p&gt;
$$
\varphi&#39;(x^*) = \varphi&#39;&#39;(x^*) = \cdots = \varphi^{(p-1)}(x^*) = 0, \quad \varphi^{(p)}(x^*) \neq 0
$$&lt;p&gt;则迭代格式在 \(x^*\) 附近为 $p$ 阶局部收敛，且有&lt;/p&gt;
$$
\lim_{k \to \infty} \frac{x^* - x_{k+1}}{(x^* - x_k)^p} = (-1)^{p-1} \frac{\varphi^{(p)}(x^*)}{p!}
$$&lt;p&gt;设 \(x^*\) 是方程 $f(x) = 0$ 的 $m$ 重根，则
&lt;/p&gt;
$$
\varphi&#39;(x^*) = 1 - \frac{1}{m} 
$$&lt;ul&gt;
&lt;li&gt;当 $m = 1$，即 \(x^*\) 为方程单根时，$\varphi&amp;rsquo;(x^*) = 0$，Newton 迭代至少二阶局部收敛。&lt;/li&gt;
&lt;li&gt;当 $m \geq 2$，即 \(x^*\) 为方程 $m (m \geq 2)$ 重根时，$|\varphi&amp;rsquo;(x^*)| &amp;lt; 1$，Newton 迭代一阶（线性）局部收敛。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;补充：
&lt;/p&gt;
$$
\lim_{k \to \infty} \frac{x^* - x_{k+1}}{(x^* - x_k)^2} = -\frac{f&#39;&#39;(x^*)}{2 f&#39;(x^*)}
$$&lt;h3 id=&#34;newton-迭代法的大范围收敛性&#34;&gt;Newton 迭代法的大范围收敛性
&lt;/h3&gt;&lt;p&gt;设 $f(x) \in C^2[a, b]$，且满足：
&lt;/p&gt;
$$f(a) f(b) &lt; 0, \quad f&#39;(x) \neq 0, \quad f&#39;&#39;(x) 保号,\quad a - \frac{f(a)}{f&#39;(a)} \leq b , \quad b - \frac{f(b)}{f&#39;(b)} \ge a $$&lt;p&gt;
则对任意初值 $x_0 \in [a, b]$，迭代格式 $x_{k+1} = x_k - \frac{f(x_k)}{f&amp;rsquo;(x_k)}$ 收敛于方程 $f(x) = 0$ 在 $[a, b]$ 上的唯一实根 $x^*$。&lt;/p&gt;
&lt;h3 id=&#34;重根的-newton-迭代法&#34;&gt;重根的 Newton 迭代法
&lt;/h3&gt;&lt;p&gt;设 \(x^*\) 是方程 $f(x) = 0$ 的 $m$ 重根&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若 $m$ 已知，迭代改为：&lt;/li&gt;
&lt;/ul&gt;
$$
x_{k+1} = x_k - m \frac{f(x_k)}{f&#39;(x_k)},\quad k = 0, 1, \cdots.
$$&lt;ul&gt;
&lt;li&gt;若 $m$ 未知，记 $u(x) = \frac{f(x)}{f&amp;rsquo;(x)}$，此时 \(x^*\) 是方程 $u(x) = 0$ 的单根，迭代改为：&lt;/li&gt;
&lt;/ul&gt;
$$
x_{k+1} = x_k - \frac{u(x_k)}{u&#39;(x_k)},\quad k = 0, 1, \cdots.
$$&lt;h2 id=&#34;线性方程组的数值解法&#34;&gt;线性方程组的数值解法
&lt;/h2&gt;&lt;h3 id=&#34;三角形方程组的回代法&#34;&gt;三角形方程组的回代法
&lt;/h3&gt;&lt;p&gt;设线性方程组 $Ax = b$ 已化为上三角形形式：
&lt;/p&gt;
$$
\begin{cases}
a_{11} x_1 + a_{12} x_2 + \cdots + a_{1n} x_n = b_1 \\
\quad \quad \quad \vdots \\
0 \quad + 0 \quad + \cdots + a_{nn} x_n = b_n
\end{cases}
$$&lt;p&gt;
则回代法求解步骤为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算 $x_n = \frac{b_n}{a_{nn}}$&lt;/li&gt;
&lt;li&gt;对 $k = n-1, n-2, \cdots, 1$，依次计算
$$
x_k = \frac{b_k - \sum\limits_{j=k+1}^{n} a_{kj} x_j}{a_{kk}}
$$&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;列主元高斯消去法&#34;&gt;列主元高斯消去法
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在第 k 步消元之前, 从第 k 列位于对角线以下的元素中选绝对值最大者作为主元,然后进行消元。&lt;/li&gt;
&lt;li&gt;使用回代法求解上三角形方程组 $Ux = y$，其中 $U$ 为消元后的系数矩阵，$y$ 为更新后的常数向量。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;三对角方程组的追赶法&#34;&gt;三对角方程组的追赶法
&lt;/h3&gt;&lt;p&gt;设三对角方程组为：
&lt;/p&gt;
$$
\begin{bmatrix}
b_1 &amp; c_1 &amp; 0 &amp; \cdots &amp; 0 \\
a_2 &amp; b_2 &amp; c_2 &amp; \cdots &amp; 0 \\
0 &amp; a_3 &amp; b_3 &amp; \cdots &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; a_n &amp; b_n
\end{bmatrix}
\begin{bmatrix}
x_1 \\
x_2 \\
x_3 \\
\vdots \\
x_n
\end{bmatrix}=
\begin{bmatrix}
d_1 \\
d_2 \\
d_3 \\
\vdots \\
d_n
\end{bmatrix}
$$&lt;p&gt;
则追赶法求解步骤为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消元过程：
$$
\begin{cases}
\beta_1 = b_1, y_1 = d_1 \\
l_i = \frac{a_i}{\beta_{i-1}}, \quad \beta_i = b_i - l_i c_{i-1}, \quad y_i = d_i - l_i y_{i-1}  \quad i = 2, 3, \cdots, n 
\end{cases}
$$&lt;/li&gt;
&lt;li&gt;回代过程：&lt;br&gt;
得到同解三角方程组为
$$
\begin{bmatrix}
\beta_1 &amp; c_1 &amp; 0 &amp; \cdots &amp; 0 \\
0 &amp; \beta_2 &amp; c_2 &amp; \cdots &amp; 0 \\
0 &amp; 0 &amp; \beta_3 &amp; \cdots &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; \beta_n
\end{bmatrix}
\begin{bmatrix}
x_1 \\
x_2 \\
x_3 \\
\vdots \\
x_n
\end{bmatrix}=
\begin{bmatrix}
y_1 \\
y_2 \\
y_3 \\
\vdots \\
y_n
\end{bmatrix}
$$
计算
$$ 
\begin{cases}
x_n = \frac{y_n}{\beta_n} \\
x_i = \frac{y_i - c_i x_{i+1}}{\beta_i} \quad i = n-1, n-2, \cdots, 1
\end{cases} 
$$&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;向量范数&#34;&gt;向量范数
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;定义：非负性、齐次性、三角不等式&lt;/li&gt;
&lt;li&gt;常用向量范数：
&lt;ul&gt;
&lt;li&gt;$L_1$ 范数：$||x||_ 1 = \sum\limits_{i=1}^{n} |x_i|$&lt;/li&gt;
&lt;li&gt;$L_{\infty}$ 范数：$||x||_ {\infty} = \max\limits_{1 \leq i \leq n} |x_i|$&lt;/li&gt;
&lt;li&gt;$L_2$ 范数：$||x||_ 2 =\sqrt{ \sum\limits_{i=1}^{n} |x_i|^2 }$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;矩阵范数&#34;&gt;矩阵范数
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;算子范数：$||A|| = \max\limits_{x \neq 0} \frac{||Ax||}{||x||}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;谱半径：$\rho(A) = \max\limits_{1 \leq i \leq n} |\lambda_i|$，其中 $\lambda_i$ 为矩阵 $A$ 的特征值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常用矩阵范数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$L_1$ 范数：$||A||_ 1 = \max\limits_{1 \leq j \leq n} \sum\limits_{i=1}^{n} |a_{ij}| \quad$ 按列求和的最大值&lt;/li&gt;
&lt;li&gt;$L_{\infty}$ 范数：$||A||_ {\infty} = \max\limits_{1 \leq i \leq n} \sum\limits_{j=1}^{n} |a_{ij}| \quad$ 按行求和的最大值&lt;/li&gt;
&lt;li&gt;$L_2$ 范数：$||A||_ 2 = \sqrt{\rho(A^T A)}$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;条件数：$cond(A) = ||A|| \cdot ||A^{-1}||$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;谱半径与2范数的关系：$\rho(A) \leq ||A||_ 2$&lt;br&gt;
如果 $A$ 是对称矩阵，则 $\rho(A) = ||A||_ 2$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;迭代法求解线性方程组&#34;&gt;迭代法求解线性方程组
&lt;/h3&gt;&lt;p&gt;将线性方程组 Ax = b 写为分量形式：
&lt;/p&gt;
$$
\begin{cases}
a_{11} x_1 + a_{12} x_2 + \cdots + a_{1n} x_n = b_1 \\
a_{21} x_1 + a_{22} x_2 + \cdots + a_{2n} x_n = b_2 \\
\quad \quad \quad \vdots \\
a_{n1} x_1 + a_{n2} x_2 + \cdots + a_{nn} x_n = b_n
\end{cases}
$$&lt;p&gt;
从第 $i$ 个方程中解出 $x_i$，得到如下同解方程组：
&lt;/p&gt;
$$
\begin{cases}
x_1 = (b_1-a_{12}x_2-a_{13} x_3 \cdots - a_{1n} x_n)/a_{11} \\
x_2 = (b_2 - a_{21} x_1 - a_{23} x_3 - \cdots - a_{2n} x_n)/a_{22} \\
\quad \quad \quad \vdots \\
x_n = (b_n - a_{n1} x_1 - a_{n2} x_2 - \cdots - a_{n,n-1} x_{n-1})/a_{nn}
\end{cases}
$$&lt;ol&gt;
&lt;li&gt;Jacobi 迭代格式：
$$
\begin{cases}
x_1^{(k+1)} = (b_1 - a_{12} x_2^{(k)} - a_{13} x_3^{(k)} - \cdots - a_{1n} x_n^{(k)})/a_{11} \\
x_2^{(k+1)} = (b_2 - a_{21} x_1^{(k)} - a_{23} x_3^{(k)} - \cdots - a_{2n} x_n^{(k)})/a_{22} \\
\quad \quad \quad \vdots \\
x_n^{(k+1)} = (b_n - a_{n1} x_1^{(k)} - a_{n2} x_2^{(k)} - \cdots - a_{n,n-1} x_{n-1}^{(k)})/a_{nn}
\end{cases}
$$&lt;/li&gt;
&lt;li&gt;Gauss-Seidel 迭代格式：&lt;br&gt;
用新分量替换旧分量
$$
\begin{cases}
x_1^{(k+1)} = (b_1 - a_{12} x_2^{(k)} - a_{13} x_3^{(k)} - \cdots - a_{1n} x_n^{(k)})/a_{11} \\
x_2^{(k+1)} = (b_2 - a_{21} x_1^{(k+1)} - a_{23} x_3^{(k)} - \cdots - a_{2n} x_n^{(k)})/a_{22} \\
\quad \quad \quad \vdots \\
x_n^{(k+1)} = (b_n - a_{n1} x_1^{(k+1)} - a_{n2} x_2^{(k+1)} - \cdots - a_{n,n-1} x_{n-1}^{(k+1)})/a_{nn}
\end{cases}
$$&lt;/li&gt;
&lt;li&gt;SOR 迭代格式：&lt;br&gt;
第k+1次迭代近似值和第k次迭代近似值的加权平均
$$
\begin{cases}
x_1^{(k+1)} = (1-\omega) x_1^{(k)} + \omega (b_1 - a_{12} x_2^{(k)} - a_{13} x_3^{(k)} - \cdots - a_{1n} x_n^{(k)}) /a_{11} \\
x_2^{(k+1)} = (1-\omega) x_2^{(k)} + \omega (b_2 - a_{21} x_1^{(k+1)} - a_{23} x_3^{(k)} - \cdots - a_{2n} x_n^{(k)}) /a_{22} \\
\quad \quad \quad \vdots \\
x_n^{(k+1)} = (1-\omega) x_n^{(k)} + \omega (b_n - a_{n1} x_1^{(k+1)} - a_{n2} x_2^{(k+1)} - \cdots - a_{n,n-1} x_{n-1}^{(k+1)}) /a_{nn}
\end{cases}
$$&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;迭代格式的收敛性&#34;&gt;迭代格式的收敛性
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;迭代格式收敛的充分必要条件：迭代矩阵 $B$ 的谱半径 $\rho(B) &amp;lt; 1$&lt;/li&gt;
&lt;li&gt;Jacobi 迭代格式的收敛性:
&lt;ul&gt;
&lt;li&gt;谱半径判断：迭代矩阵特征方程为 $|\lambda D+L+U| = 0$ (系数矩阵的对角线乘 $\lambda$ )&lt;/li&gt;
&lt;li&gt;充分条件判断：如果系数矩阵 $A$ 严格对角占优，则 Jacobi 迭代格式收敛。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Gauss-Seidel 迭代格式的收敛性:
&lt;ul&gt;
&lt;li&gt;谱半径判断：迭代矩阵特征方程为 $|\lambda (D+L)+U| = 0$ (系数矩阵的下三角乘 $\lambda$ )&lt;/li&gt;
&lt;li&gt;充分条件判断：如果系数矩阵 $A$ 严格对角占优，则 Gauss-Seidel 迭代格式收敛。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SOR 迭代格式的收敛性:
&lt;ul&gt;
&lt;li&gt;收敛的必要条件：$0 &amp;lt; \omega &amp;lt; 2$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;多项式插值&#34;&gt;多项式插值
&lt;/h2&gt;&lt;h3 id=&#34;拉格朗日插值多项式&#34;&gt;拉格朗日插值多项式
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;定义：设插值节点为 $x_0, x_1, \cdots, x_n$，对应的函数值为 $f(x_0), f(x_1), \cdots, f(x_n)$，若存在一个次数不超过 $n$ 的多项式 $p_n(x)$，使得
&lt;/p&gt;
$$p_n(x_i) = f(x_i), \quad i = 0, 1, \cdots, n$$&lt;p&gt;
成立，则称 $p_n(x)$ 为函数 $f(x)$ 的 $n$ 次插值多项式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定理：满足上述条件的 $n$ 次多项式 $p_n(x)$ 存在且唯一。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本插值多项式：定义 $n+1$ 个基本插值多项式 $l_k(x)$，满足
&lt;/p&gt;
$$
l_k(x_j) = \begin{cases}1, &amp; j = k \\ 0, &amp; j \neq k \end{cases}
$$&lt;p&gt;
则 $l_k(x)$ 可表示为：
&lt;/p&gt;
$$
l_k(x) = \prod\limits_{ \substack{i=0  \\  i \neq k}}^{n} \frac{x - x_i}{x_k - x_i}
$$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用基本插值多项式， $n$ 次 Lagrange 插值多项式为：
&lt;/p&gt;
$$
L_n(x) = \sum\limits_{k=0}^{n} f(x_k) l_k(x)= \sum\limits_{k=0}^{n} f(x_k) \prod\limits_{ \substack{i=0  \\  i \neq k}}^{n} \frac{x - x_i}{x_k - x_i}
$$&lt;p&gt;
$l_0(x), l_1(x), \cdots, l_n(x)$ 线性无关，称为 $n$ 次 Lagrange 插值基函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插值余项及误差估计：若函数 $f(x)$ 在区间 $[a, b]$ 上具有 $n+1$ 阶连续导数，则对任意 $x \in [a, b]$，存在 $\xi \in (a, b)$，使得
&lt;/p&gt;
$$
R_n(x)=f(x) - L_n(x) = \frac{f^{(n+1)}(\xi)}{(n+1)!} \omega_{n+1}(x)
$$&lt;p&gt;
其中 $\omega_{n+1}(x) = (x - x_0)(x - x_1) \cdots (x - x_n)$, $\quad \xi$ 与 $x$ 有关。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;newton-插值多项式&#34;&gt;Newton 插值多项式
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;差商的定义：
$$
f[x_i] = f(x_i)
$$
$$
f[x_i, x_{i+1}, \cdots, x_{i+k}] = \frac{f[x_{i+1}, \cdots, x_{i+k}] - f[x_i, \cdots, x_{i+k-1}]}{x_{i+k} - x_i}
$$&lt;/li&gt;
&lt;li&gt;$n$ 次 Newton 插值多项式定义为：
$$
L_n(x) = f[x_0] + f[x_0, x_1](x - x_0) + f[x_0, x_1, x_2](x - x_0)(x - x_1) \\+ \cdots + f[x_0, x_1, \cdots, x_n](x - x_0)(x - x_1) \cdots (x - x_{n-1})
$$&lt;/li&gt;
&lt;li&gt;$k$ 阶差商与 $k$ 阶导数的关系：
$$
f[x_0, x_1, \cdots, x_k] = \frac{f^{(k)}(\eta)}{k!}, \quad \eta \in (\min(x_0, \cdots, x_k), \max(x_0, \cdots, x_k))
$$&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;hermite-插值多项式&#34;&gt;Hermite 插值多项式
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;定义：给定$n+1$ 个互异节点 $x_0, x_1, \cdots, x_n$上的函数值和直到$m_i$阶的导数值，令 $m = \sum \limits_0^n(m_i+1)-1$，
若存在一个次数不超过 $m$ 的多项式 $H_m(x)$，使得
&lt;/p&gt;
$$
\begin{cases}
H_m^{(j)}(x_i) = f^{(j)}(x_i), \quad j = 0, 1, \cdots, m_i \\
i = 0, 1, \cdots, n
\end{cases}
$$&lt;p&gt;
则称 $H_m(x)$ 为函数 $f(x)$ 的 Hermite 插值多项式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重节点插值：将上述插值问题看成是在 $m + 1$ 不同节点上的 Newton 插值, 然后取极限就成为 $n + 1$ 不同节点上的 Hermite 插值, 称之为重节点插值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$m$次 Hermite 插值多项式为：
&lt;/p&gt;
$$
H_m(x) = f[x_0] + f[x_0, x_0](x - x_0) + f[x_0, x_0, x_1](x - x_0)^2 \\+
 \cdots + f[\underbrace{x_0, x_0, \cdots, x_0}_{m_0+1}, \underbrace{x_1, x_1, \cdots, x_1}_{m_1+1}, \cdots, \underbrace{x_n, x_n, \cdots, x_n}_{m_n+1}](x - x_0)^{m_0+1}(x - x_1)^{m_1+1} \cdots (x - x_n)^{m_n}
$$&lt;p&gt;
重节点差商公式：
&lt;/p&gt;
$$
f[\underbrace{x_i, x_i, \cdots, x_i}_{k+1}] = \frac{f^{(k)}(x_i)}{k!} \\
f[x_0, x_0,x_1] = \frac{f[x_0, x_1] - f[x_0, x_0]}{x_1 - x_0} 
$$&lt;p&gt;
插值余项为：
&lt;/p&gt;
$$
R_m(x) = f(x) - H_m(x) = \frac{f^{(m+1)}(\xi)}{(m+1)!} (x - x_0)^{m_0+1}(x - x_1)^{m_1+1} \cdots (x - x_n)^{m_n+1}
$$&lt;h3 id=&#34;3次样条插值函数&#34;&gt;3次样条插值函数
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;定义：每段小区间上用3次多项式进行插值，且在区间上具有连续二阶导数，称为3次样条插值函数。&lt;br&gt;
要求3次样条插值函数 $S(x)$，每个小区间要确定4个参数，共要确定 $4n$ 个参数。&lt;br&gt;
在每个节点处满足下面的连续性条件:&lt;br&gt;
$S(x_j-0) = S(x_j+0),\quad S&amp;rsquo;(x_j-0) = S&amp;rsquo;(x_j+0),\quad S&amp;rsquo;&amp;rsquo;(x_j-0) = S&amp;rsquo;&amp;rsquo;(x_j+0), \quad j = 1, 2, \cdots, n-1$&lt;br&gt;
共有 $3(n-1)$ 个条件，加上$n+1$ 个插值条件，共有 $4n - 2$ 个条件，还要加上2个条件，才能确定 $4n$ 个参数。&lt;br&gt;
常用的附加条件有：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;(边界条件) 已知两端点的一阶导数, 即 $S&amp;rsquo;(x_0) = f&amp;rsquo;(x_0), \quad S&amp;rsquo;(x_n) = f&amp;rsquo;(x_n)$&lt;/li&gt;
&lt;li&gt;(边界条件) 已知两端点的二阶导数, 即 $S&amp;rsquo;&amp;rsquo;(x_0) = f&amp;rsquo;&amp;rsquo;(x_0), \quad S&amp;rsquo;&amp;rsquo;(x_n) = f&amp;rsquo;&amp;rsquo;(x_n)$
若令 $S&amp;rsquo;&amp;rsquo;(x_0) = 0, \quad S&amp;rsquo;&amp;rsquo;(x_n) = 0$，则称为自然边界条件。&lt;/li&gt;
&lt;li&gt;(连接条件) 要求 $S&amp;rsquo;&amp;rsquo;&amp;rsquo;(x)$ 在 $x_1$ 和 $x_{n-1}$ 处连续，即 $S&amp;rsquo;&amp;rsquo;&amp;rsquo;(x_1-0) = S&amp;rsquo;&amp;rsquo;&amp;rsquo;(x_1+0), \quad S&amp;rsquo;&amp;rsquo;&amp;rsquo;(x_{n-1}-0) = S&amp;rsquo;&amp;rsquo;&amp;rsquo;(x_{n-1}+0)$&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;求法：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$S(x)=y_j+{f[x_j,x_{j+1}]-(\frac{1}{3}M_j+\frac{1}{6}M_{j+1})h_j}(x-x_j)+ \frac{M_j}{2}(x - x_j)^2 + \frac{M_{j+1} - M_j}{6h_j}(x - x_j)^3, \quad x \in [x_j, x_{j+1}]，j=0,1,⋯,n-1$&lt;/p&gt;
&lt;p&gt;其中 $h_j = x_{j+1} - x_j$，$M_j = S&amp;rsquo;&amp;rsquo;(x_j)$&lt;/p&gt;
&lt;p&gt;对于边界条件 $S&amp;rsquo;(x_0) = f&amp;rsquo;(x_0), \quad S&amp;rsquo;(x_n) = f&amp;rsquo;(x_n)$，可列出如下方程组求解 $M_j$：
&lt;/p&gt;
$$\begin{bmatrix}
2 &amp; 1 \\
\mu_1 &amp; 2 &amp; \lambda_1 \\
&amp; \mu_2 &amp; 2 &amp; \lambda_2 \\
&amp; &amp; \ddots &amp; \ddots &amp; \ddots \\
&amp; &amp; &amp; \mu_{n-1} &amp; 2 &amp; \lambda_{n-1} \\
&amp; &amp; &amp; &amp; 1 &amp; 2
\end{bmatrix}
\begin{bmatrix}
M_0 \\
M_1 \\
M_2 \\
\vdots \\
M_{n-1} \\
M_n
\end{bmatrix} =
\begin{bmatrix}
d_0 \\
d_1 \\
d_2 \\
\vdots \\
d_{n-1} \\
d_n
\end{bmatrix}
$$&lt;p&gt;
对于边界条件 $S&amp;rsquo;&amp;rsquo;(x_0) = f&amp;rsquo;&amp;rsquo;(x_0), \quad S&amp;rsquo;&amp;rsquo;(x_n) = f&amp;rsquo;&amp;rsquo;(x_n)$，可列出如下方程组求解 $M_j$：
&lt;/p&gt;
$$\begin{bmatrix}
2 &amp; \lambda_1 \\
\mu_2 &amp; 2 &amp; \lambda_2 \\
&amp; \mu_3 &amp; 2 &amp; \lambda_3 \\
&amp; &amp; \ddots &amp; \ddots &amp; \ddots \\
&amp; &amp; &amp; \mu_{n-2} &amp; 2 &amp; \lambda_{n-2} \\
&amp; &amp; &amp; &amp; \mu_{n-1} &amp; 2
\end{bmatrix}
\begin{bmatrix}
M_1 \\
M_2 \\
M_3 \\
\vdots \\
M_{n-2} \\ 
M_{n-1}
\end{bmatrix} =
\begin{bmatrix}
d_1-\mu_1 f&#39;&#39;(x_0) \\
d_2 \\
d_3 \\
\vdots \\
d_{n-2} \\
d_{n-1}-\lambda_{n-1} f&#39;&#39;(x_n)
\end{bmatrix}
$$&lt;p&gt;
其中
&lt;/p&gt;
$$\mu_j = \frac{h_{j-1}}{h_{j-1} + h_j}, \quad \lambda_j = \frac{h_j}{h_{j-1} + h_j}=1-\mu_j, \quad j = 1, 2, \cdots, n-1$$&lt;p&gt;
&lt;/p&gt;
$$d_0 = 6f[x_0,x_0,x_1], \quad d_n = 6f[x_{n-1},x_n,x_n]$$&lt;p&gt;
&lt;/p&gt;
$$d_j = 6 \left( f[x_{j-1}, x_j, x_{j+1}] \right), \quad j = 1, 2, \cdots, n-1$$&lt;h2 id=&#34;多项式逼近&#34;&gt;多项式逼近
&lt;/h2&gt;&lt;h3 id=&#34;最佳一致逼近&#34;&gt;最佳一致逼近
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;连续函数的范数：设$f\in C[a,b]$，记
$$
||f||_1 = \int_a^b |f(x)| dx,\quad
||f||_{\infty} = \max_{a \leq x \leq b} |f(x)|,\quad
||f||_2 = \sqrt{ \int_a^b |f(x)|^2 dx } $$&lt;/li&gt;
&lt;li&gt;最佳一致逼近多项式&lt;br&gt;
定义：设 $f(x) \in C[a,b]$，$M_n$ 为次数不超过 $n$ 的任意多项式集合，若$\exists p_n\in M_n$，使得对任意 $q_n \in M_n$，有
$$||f - p_n||_{\infty} \leq ||f - q_n||_{\infty}$$
则称 $p_n(x)$ 为函数 $f(x)$ 在区间 $[a,b]$ 上的$n$次最佳一致逼近多项式。&lt;/li&gt;
&lt;li&gt;一次最佳一致逼近多项式求法：&lt;br&gt;
设 $p_1(x) = c_0 + c_1 x$，若 $f&amp;rsquo;&amp;rsquo;(x)$ 在 $(a, b)$ 内存在且保号，则 $f(x) − p_1 (x)$ 在 [a, b] 内有 3 个交错偏差点 $a, x_1 , b$, 于是可得
$$\begin{cases}
f(a) - p_1(a) = -[f(x_1)-p_1(x_1)] = f(b)-p_1(b) \\
f&#39;(x_1) - p_1&#39;(x_1) = 0
\end{cases}$$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;最佳平方逼近&#34;&gt;最佳平方逼近
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;最佳平方逼近多项式&lt;br&gt;
定义：设$X$为内积空间， $f \in X$，$M$ 为$X$的子空间，$\varphi_0,\varphi_1,\cdots,\varphi_m$为$M$的一组基，若$\exists \varphi\in M_n$，使得对任意 $\psi \in M$，有
$$||f - \varphi|| \leq ||f - \psi||$$
则称 $ \varphi$ 是 $f$ 在 $M$ 中的最佳平方逼近元&lt;/li&gt;
&lt;li&gt;最佳平方逼近多项式求法：&lt;br&gt;
如果$\varphi_i(x)=x^i(i=0,1,\cdots,m)$，设 $p(x) = \sum\limits_{i=0}^{m} c_i \varphi_i(x)$，则 $p(x)$ 称为 $f(x)$ 在 $[a, b]$ 上的 $m$ 次最佳平方逼近多项式&lt;br&gt;
$c_0 , c_1 , \cdots , c_m$ 是下面的 (正规) 方程组的解:
$$\begin{bmatrix}
(\varphi_0, \varphi_0) &amp; (\varphi_0, \varphi_1) &amp; \cdots &amp; (\varphi_0, \varphi_m) \\
(\varphi_1, \varphi_0) &amp; (\varphi_1, \varphi_1) &amp; \cdots &amp; (\varphi_1, \varphi_m) \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
(\varphi_m, \varphi_0) &amp; (\varphi_m, \varphi_1) &amp; \cdots &amp; (\varphi_m, \varphi_m)
\end{bmatrix}
\begin{bmatrix}
c_0 \\
c_1 \\
\vdots \\
c_m
\end{bmatrix} =
\begin{bmatrix}
(f, \varphi_0) \\
(f, \varphi_1) \\
\vdots \\
(f, \varphi_m)
\end{bmatrix}$$
其中 $(f, g) = \int_a^b f(x) g(x) dx$ 为内积。&lt;/li&gt;
&lt;li&gt;超定方程组的最小二乘解：&lt;br&gt;
设超定方程组为 $Ax = b$，其中 $A$ 为 $m \times n$ 矩阵，$m &amp;gt; n$，则其最小二乘解 $x^*$ 满足正规方程组
$$A^T A x = A^T b$$&lt;/li&gt;
&lt;li&gt;离散数据的最佳平方逼近多项式：&lt;br&gt;
给定离散数据点 $(x_i, y_i), i = 0, 1, \cdots, n$，设 $p(x) = \sum\limits_{i=0}^{m} c_i \varphi_i(x)$，如果$\varphi_k(x)=x^k$，则 $p(x)$ 称为数据点的 $m$ 次最小二乘拟合多项式。
记
$$
\mathbf{\varphi}_k =
\begin{bmatrix}
\varphi_k(x_0) \\
\varphi_k(x_1) \\
\vdots \\
\varphi_k(x_n)
\end{bmatrix}, \quad
\mathbf{y} =
\begin{bmatrix}
y_0 \\
y_1 \\
\vdots \\
y_n
\end{bmatrix}
$$&lt;br&gt;
$c_0 , c_1 , \cdots , c_n$ 是下面的 (正规) 方程组的解:
$$\begin{bmatrix}
(\varphi_0, \varphi_0) &amp; (\varphi_0, \varphi_1) &amp; \cdots &amp; (\varphi_0, \varphi_m) \\
(\varphi_1, \varphi_0) &amp; (\varphi_1, \varphi_1) &amp; \cdots &amp; (\varphi_1, \varphi_m) \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
(\varphi_m, \varphi_0) &amp; (\varphi_m, \varphi_1) &amp; \cdots &amp; (\varphi_m, \varphi_m)
\end{bmatrix}
\begin{bmatrix}
c_0 \\
c_1 \\
\vdots \\
c_m
\end{bmatrix} =
\begin{bmatrix}
(y, \varphi_0) \\
(y, \varphi_1) \\
\vdots \\
(y, \varphi_m)
\end{bmatrix}$$&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数值积分与数值微分&#34;&gt;数值积分与数值微分
&lt;/h2&gt;&lt;h3 id=&#34;插值型求积公式&#34;&gt;插值型求积公式
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;定义&lt;br&gt;
设有计算定积分 $I(f) = \int_a^b f(x) dx$ 的求积公式
$$I_n(f) = \sum\limits_{k=0}^{n} A_k f(x_k)$$
如果求积系数 $A_k=\int_a^b l_k(x) dx$，其中 $l_k(x)$ 为插值节点上的 Lagrange 基函数，则称 $I_n(f)$ 为插值型求积公式。&lt;br&gt;
截断误差为：
$$R_n(f) = I(f) - I_n(f) = \int_a^b \frac{f^{(n+1)}(\xi)}{(n+1)!}  \prod_{i=0}^n (x - x_i) dx, \quad \xi \in (a, b)$$
若函数 $f(x)$ 在&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果求积节点 $x_k$ 为等距节点，即
&lt;/p&gt;
$$x_k = a + k h, \quad h = \frac{b-a}{n}, \quad k = 0, 1, \cdots, n$$&lt;p&gt;
则称为 Newton-Cotes 求积公式，可写为：
&lt;/p&gt;
$$I_n(f) = (b-a) \sum\limits_{k=0}^{n} C_{n,k} f(x_k)$$&lt;p&gt;
2. 常用的等距节点插值型求积公式&lt;br&gt;
* 梯形公式（n=1）：&lt;/p&gt;
$$T(f) = \frac{b-a}{2} [f(a) + f(b)]$$&lt;p&gt;
* Simpson 公式（n=2）：&lt;/p&gt;
$$S(f) = \frac{b-a}{6} [f(a) + 4f\left(\frac{a+b}{2}\right) + f(b)]$$&lt;p&gt;
3. 代数精度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义：设求积公式 $I_n(f)$ 对任意次数不超过 $m$ 的多项式均精确成立，即
$$I(f) = I_n(f), \quad \forall f \in P_m$$
而至少对一个 $m+1$ 次多项式不精确成立，则称求积公式 $I_n(f)$ 的代数精度为 $m$&lt;/li&gt;
&lt;li&gt;定理：
&lt;ul&gt;
&lt;li&gt;求积公式 $I_n(f)$ 的代数精度至少为 $n$ $\Leftrightarrow$
该求积公式是插值型求积公式&lt;/li&gt;
&lt;li&gt;求积公式 $I_n(f)$ 的代数精度为$m$ $\Leftrightarrow$
求积公式对 $1,x,x^2,\cdots,x^m$ 均精确成立，而对 $x^{m+1}$ 不精确成立&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;截断误差表达式推导
&lt;ul&gt;
&lt;li&gt;梯形公式：$$R_T(f) = -\frac{(b-a)^3}{12} f&#39;&#39;(\xi), \quad \xi \in (a, b)$$&lt;/li&gt;
&lt;li&gt;Simpson 公式：$$R_S(f) = -\frac{(b-a)^5}{2880} f^{(4)}(\xi), \quad \xi \in (a, b)$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;复化求积公式&#34;&gt;复化求积公式
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;定义&lt;br&gt;
将区间 $[a, b]$ 等分为 $n$ 个小区间，每个小区间上使用相同的求积公式进行积分近似，称为复化求积公式。&lt;br&gt;
记 $h = \frac{b-a}{n},\quad x_k = a + k h,\quad k=0,1,\cdots,n$，则复化求积公式可写为：
$$I(f) = \sum\limits_{k=0}^{n-1} \int_{x_k}^{x_{k+1}} f(x) dx$$&lt;/li&gt;
&lt;li&gt;复化梯形公式
$$T_n(f) = \sum\limits_{k=0}^{n-1} \frac{h}{2} [f(x_k) + f(x_{k+1})]$$
截断误差
$$I(f)-T_n(f) = -\frac{b-a}{12}h^2 f&#39;&#39;(\eta), \quad \eta \in (a, b)$$
$$I(f)-T_{2n}(f) \approx \frac{1}{3} [T_{2n}(f) - T_n(f)]$$
递推关系式
$$T_{2n}(f) = \frac{1}{2} [T_n(f) + h \sum\limits_{k=0}^{n-1} f\left(x_{k+\frac{1}{2}}\right)]$$
其中$x_{k+\frac{1}{2}} = \frac{x_k + x_{k+1}}{2}$为新增的n个节点, $h=\frac{b-a}{n}$&lt;/li&gt;
&lt;li&gt;复化 Simpson 公式
$$S_n(f) = \sum\limits_{k=0}^{n-1} \frac{h}{6} [f(x_{k}) + 4f(x_{k+\frac{1}{2}}) + f(x_{k+1})]$$
截断误差
$$I(f)-S_n(f) = -\frac{b-a}{180}\left(\frac{h}{2}\right)^4 f^{(4)}(\eta), \quad \eta \in (a, b)$$
$$I(f)-S_{2n}(f) \approx \frac{1}{15} [S_{2n}(f) - S_n(f)]$$&lt;/li&gt;
&lt;li&gt;复化求积公式的阶数
$$h\rightarrow 0,\quad I(f)-I_n(f) = O(h^p)$$
则称复化求积公式的阶数为 $p$，由上文可知复化梯形公式为 2 阶, 复化 Simpson 公式为 4 阶&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;romberg-求积方法&#34;&gt;Romberg 求积方法
&lt;/h3&gt;&lt;p&gt;先利用复化梯形公式计算出一系列 $T_{2^k}(f)$，然后利用
&lt;/p&gt;
$$S_n(f) \approx \frac{4}{3} T_{2n}(f) - \frac{1}{3} T_n(f)$$&lt;p&gt;
&lt;/p&gt;
$$C_n(f) \approx \frac{16}{15} S_{2n}(f) - \frac{1}{15} S_n(f)$$&lt;p&gt;
&lt;/p&gt;
$$R_n(f) \approx \frac{64}{63} C_{2n}(f) - \frac{1}{63} C_n(f)$$&lt;p&gt;
依次递推，直到满足精度
&lt;/p&gt;
$$I(f) - R_n(f) \approx \frac{1}{255} [R_{2n}(f) - R_{n}(f)] &lt; \varepsilon$$&lt;h3 id=&#34;gauss-求积公式&#34;&gt;Gauss 求积公式
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;定义：适当选择求积节点 $x_k$，使得求积公式的代数精度达到 $(2n+1)$，称为 Gauss 求积公式，对应的求积点 $x_k$ 称为 Gauss 点。&lt;/li&gt;
&lt;li&gt;区间[-1,1] 上的 Gauss 求积公式
当 $n=0$ 时，1 点 Gauss 求积公式为：
$$G_0(f) = 2 f(0)$$
当 $n=1$ 时，2 点 Gauss 求积公式为：
$$G_1(f) = f\left(-\frac{1}{\sqrt{3}}\right) + f\left(\frac{1}{\sqrt{3}}\right)$$
当 $n=2$ 时，3 点 Gauss 求积公式为：
$$G_2(f) = \frac{5}{9} f\left(-\sqrt{\frac{3}{5}}\right) + \frac{8}{9} f(0) + \frac{5}{9} f\left(\sqrt{\frac{3}{5}}\right)$$&lt;/li&gt;
&lt;li&gt;区间[a,b] 上的 Gauss 求积公式&lt;br&gt;
考虑区间 $[a, b]$ 上的积分
$$\int_a^b f(x) dx$$
通过变量代换
$x = \frac{a+b}{2} + \frac{b-a}{2} t$
将区间 $[a, b]$ 上的积分转化为区间 $[-1, 1]$ 上的积分，得到
$$\int_a^b f(x) dx = \frac{b-a}{2} \int_{-1}^{1} f\left(\frac{a+b}{2} + \frac{b-a}{2} t\right) dt$$
得到 Gauss 求积公式：
$$I_n(f) =  \sum\limits_{k=0}^{n}\frac{b-a}{2} \tilde{A_k} f\left(\frac{a+b}{2} + \frac{b-a}{2} t_k\right)$$
再令$$x_k = \frac{a+b}{2} + \frac{b-a}{2} t_k,\quad A_k = \frac{b-a}{2} \tilde{A_k}$$
则有
$$I_n(f) =  \sum\limits_{k=0}^{n} A_k f(x_k)$$&lt;/li&gt;
&lt;li&gt;截断误差表达式&lt;br&gt;
Gauss 求积公式的截断误差为：
$$R_n(f) = \frac{f^{(2n+2)}(\xi)}{(2n+2)!} \int_a^b \left[ \prod_{k=0}^{n} (x - x_k) \right]^2 dx, \quad \xi \in (a, b)$$&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数值微分&#34;&gt;数值微分
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;差商代替导数值
&lt;/p&gt;
$$向前差商：f&#39;(x_0) \approx \frac{f(x_0 + h) - f(x_0)}{h}$$&lt;p&gt;
&lt;/p&gt;
$$向后差商：f&#39;(x_0) \approx \frac{f(x_0) - f(x_0 - h)}{h}$$&lt;p&gt;
&lt;/p&gt;
$$中心差商：f&#39;(x_0) \approx \frac{f(x_0 + h) - f(x_0 - h)}{2h}$$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;截断误差&lt;br&gt;
将 $f(x_0 + h), f(x_0 − h)$ 在 $x_0$ 点 Taylor 展开, 可以得
&lt;/p&gt;
$$f&#39;(x_0) - \frac{f(x_0 + h) - f(x_0)}{h} = -\frac{h}{2} f&#39;&#39;(x_0)+O(h^2)$$&lt;p&gt;
&lt;/p&gt;
$$f&#39;(x_0) - \frac{f(x_0) - f(x_0 - h)}{h} = \frac{h}{2} f&#39;&#39;(x_0)+O(h^2)$$&lt;p&gt;
&lt;/p&gt;
$$f&#39;(x_0) - \frac{f(x_0 + h) - f(x_0 - h)}{2h} = -\frac{h^2}{6} f^{(3)}(x_0)+O(h^3)$$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插值型求导公式&lt;br&gt;
建立插值多项式 $p_n(x)$作为函数 $f(x)$ 的近似，取其导数 $p_n&amp;rsquo;(x)$ 作为 $f&amp;rsquo;(x)$ 的近似，称为插值型求导公式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;常微分方程数值解&#34;&gt;常微分方程数值解
&lt;/h2&gt;&lt;h3 id=&#34;euler-方法&#34;&gt;Euler 方法
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Euler 公式：
&lt;/p&gt;
$$y_{i+1} = y_i + h f(x_i, y_i), \quad i=0,1,\cdots,n-1$$&lt;p&gt;
其中 $h$ 为步长，$y_i$ 为 $y(x_i)$ 的近似值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;梯形公式：
&lt;/p&gt;
$$y_{i+1} = y_i + \frac{h}{2} [f(x_i, y_i) + f(x_{i+1}, y_{i+1})], \quad i=0,1,\cdots,n-1$$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;预测校正公式(改进的Euler公式)：
&lt;/p&gt;
$$\begin{cases}
预测：y^{(p)}_{i+1} = y_i + h f(x_i, y_i) \\
校正：y_{i+1} = y_i + \frac{h}{2} [f(x_i, y_i) + f(x_{i+1}, y^{(p)}_{i+1})]
\end{cases}$$&lt;p&gt;
局部截断误差：$R_{i+1} = y(x_{i+1}) - y(x_i) - \frac{h}{2} [f(x_i, y(x_i)) + f(x_{i+1}, y(x_i)+hf(x_i,y(x_i))]$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;求法：分别求出预测公式的截断误差 $R^{（p）}_ {i+1}$ 和校正公式的截断误差 $R^{（c）}_ {i+1}$ ，则$R_{i+1}$可以通过加项减项凑出$R^{（p）}_ {i+1}$和$R^{（c）}_ {i+1}$&lt;br&gt;
若$R_{i+1}=O(h^{p+1})$，则称该公式为 $p$ 阶的。Euler 公式为 1 阶，梯形公式和预测校正公式为 2 阶。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;整体截断误差：$E(h)= \max\limits_{0 \leq i \leq n} |y(x_i) - y_i^{[h]}|$&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;runge-kutta-方法&#34;&gt;Runge-Kutta 方法
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;r级 Runge-Kutta 公式：
$$\begin{cases}
y_{i+1} = y_i + h \sum\limits_{j=1}^{r} \alpha_j k_j \\
k_1 = f(x_i, y_i) \\
k_2 = f(x_i + \lambda_2 h, y_i + h (\mu_{21} k_1)) \\
k_3 = f(x_i + \lambda_3 h, y_i + h (\mu_{31} k_1 + \mu_{32} k_2)) \\
\quad \vdots \\
k_r = f(x_i + \lambda_j h, y_i + h (\mu_{r1} k_1 + \mu_{r2} k_2 + \cdots + \mu_{r,r-1} k_{r-1}))
\end{cases}$$&lt;/li&gt;
&lt;li&gt;2阶 Runge-Kutta 公式推导：
当 $r=2$ 时，有
$$\begin{cases}
y_{i+1} = y_i + h (\alpha_1 k_1 + \alpha_2 k_2) \\
k_1 = f(x_i, y_i) \\
k_2 = f(x_i + \lambda_2 h, y_i + h \mu_{21} k_1)
\end{cases}$$
其局部截断误差为
$$\begin{cases}
R_{i+1} = y(x_{i+1}) - y(x_i) - h (\alpha_1 K_1 + \alpha_2 K_2) \\
K_1 = f(x_i, y(x_i)) \\
K_2 = f(x_i + \lambda_2 h, y(x_i) + h \mu_{21} K_1)
\end{cases}$$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将 $y(x_{i+1})$ 在 $x_i$ 点 Taylor 展开, 将 $K_2$ 在 $(x_i, y_i)$ 点 Taylor 展开&lt;br&gt;
代入使公式具有二阶精度，即$R_{i+1}=O(h^{3})$，得
&lt;/p&gt;
$$\begin{cases}
\alpha_1 + \alpha_2 = 1 \\
\alpha_2 \lambda_2 = \frac{1}{2} \\
\alpha_2 \mu_{21} = \frac{1}{2}
\end{cases}$$&lt;h2 id=&#34;偏微分方程数值解&#34;&gt;偏微分方程数值解
&lt;/h2&gt;&lt;h3 id=&#34;抛物型方程的差分解法&#34;&gt;抛物型方程的差分解法
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;网格剖分
将求解区域 $[0, l] \times [0, T]$ 作等距网格剖分，设空间步长为 $h = \frac{l}{M}$，时间步长为 $\tau = \frac{T}{N}$，则网格点为
&lt;/p&gt;
$$(x_i, t_k) = (i h, k \tau), \quad 0 \leq i \leq M, 0 \leq k \leq N$$&lt;p&gt;
记 $u_i^k$ 为 $u(x_i, t_k)$ 的近似值。$r = \frac{a \tau}{h^2}$ 为步长比。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;差分格式推导&lt;br&gt;
考虑下面的定解问题：
&lt;/p&gt;
$$\frac{\partial u}{\partial t} - a \frac{\partial^2 u}{\partial x^2}=f(x,t), \quad a &gt; 0$$&lt;p&gt;
&lt;/p&gt;
$$u(x,0) = \varphi(x), \quad x \in [0, l]$$&lt;p&gt;
&lt;/p&gt;
$$u(0,t) = \alpha(t), \quad u(l,t) = \beta(t), \quad t \in [0, T]$$&lt;p&gt;
差分格式推导常用公式：
&lt;/p&gt;
$$g&#39;(x_0)= \frac{1}{h}[g(x_0+h)-g(x_0)] - \frac{h}{2} g&#39;&#39;(\xi),\quad x_0 &lt; \xi &lt; x_0 + h;$$&lt;p&gt;
&lt;/p&gt;
$$g&#39;(x_0)= \frac{1}{h}[g(x_0)-g(x_0-h)] + \frac{h}{2} g&#39;&#39;(\xi),\quad x_0 - h &lt; \xi &lt; x_0;$$&lt;p&gt;
&lt;/p&gt;
$$g&#39;(x_0)= \frac{1}{2h}[g(x_0+h)-g(x_0-h)] - \frac{h^2}{6} g^{(3)}(\xi),\quad x_0 - h &lt; \xi &lt; x_0 + h;$$&lt;p&gt;
&lt;/p&gt;
$$g&#39;&#39;(x_0)= \frac{1}{h^2}[g(x_0+h)-2g(x_0)+g(x_0-h)] - \frac{h^2}{12} g^{(4)}(\xi),\quad x_0 - h &lt; \xi &lt; x_0 + h;$$&lt;p&gt;
&lt;/p&gt;
$$g(x_0)= \frac{1}{2}[g(x_0+h)+g(x_0-h)] - \frac{h^2}{2} g&#39;&#39;(\xi),\quad x_0 - h &lt; \xi &lt; x_0 + h.$$&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>Navila复现笔记</title>
        <link>https://caibb16.github.io/p/navila%E5%A4%8D%E7%8E%B0%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Wed, 24 Dec 2025 12:39:23 +0800</pubDate>
        
        <guid>https://caibb16.github.io/p/navila%E5%A4%8D%E7%8E%B0%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h2 id=&#34;引言&#34;&gt;引言
&lt;/h2&gt;&lt;p&gt;本文尝试对Navila论文进行复现，引用如下：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://arxiv.org/abs/2412.04453&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Paper Link&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/AnjieCheng/NaVILA&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Project Link&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;论文解读&#34;&gt;论文解读
&lt;/h2&gt;&lt;p&gt;NaVILA: Legged Robot Vision-Language-Action  Model for Navigation&lt;/p&gt;
&lt;h3 id=&#34;基本目标&#34;&gt;基本目标
&lt;/h3&gt;&lt;p&gt;在收到人类指令后，NaVILA 使用视觉语言模型处理 RGB 视频帧，并运用运动技能在机器人上执行任务。该机器人能够成功完成长时程导航任务，并在复杂环境中安全运行。&lt;br&gt;
该项目的创新基于端到端的VLA系统，该系统对通用 VLM 进行微调，以生成量化的低级动作，这个过程的推理和执行十分具有挑战性。本项目为了用更好的方式表示动作，建立了一个两级框架，将高层次的视觉语言理解与低层次的运动控制分开。&lt;/p&gt;
&lt;h3 id=&#34;两级框架&#34;&gt;两级框架
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;高层次视觉语言理解：VLM输出语言形式的中级动作，例如“右转 30 度”。中级动作输出传达了位置和方向信息，指导机器人的导航策略。&lt;/li&gt;
&lt;li&gt;低层次运动控制：训练一个低级视觉运动策略来遵循指令以对导航指令进行执行，具体来说就是将VLM的高层语言导航指令转换为精确的联合动作。
&lt;img src=&#34;https://caibb16.github.io/p/navila%E5%A4%8D%E7%8E%B0%E7%AC%94%E8%AE%B0/image.png&#34;
	width=&#34;1128&#34;
	height=&#34;308&#34;
	srcset=&#34;https://caibb16.github.io/p/navila%E5%A4%8D%E7%8E%B0%E7%AC%94%E8%AE%B0/image_hu_19ca08b344dce6ca.png 480w, https://caibb16.github.io/p/navila%E5%A4%8D%E7%8E%B0%E7%AC%94%E8%AE%B0/image_hu_535d66e3322dd091.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Navila架构图&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;366&#34;
		data-flex-basis=&#34;878px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;实现方法&#34;&gt;实现方法
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;训练VLA用于导航
&lt;ul&gt;
&lt;li&gt;选择基于图像的视觉语言模型VILA&lt;/li&gt;
&lt;li&gt;将历史和当前观测的标记与导航指令整合，构建导航任务提示&lt;/li&gt;
&lt;li&gt;从人类视频中收集轨迹-指令对以增强在连续空间的导航能力&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;训练过程如下图：&lt;br&gt;
&lt;img src=&#34;https://caibb16.github.io/p/navila%E5%A4%8D%E7%8E%B0%E7%AC%94%E8%AE%B0/image2.png&#34;
	width=&#34;1046&#34;
	height=&#34;441&#34;
	srcset=&#34;https://caibb16.github.io/p/navila%E5%A4%8D%E7%8E%B0%E7%AC%94%E8%AE%B0/image2_hu_9745ae400f7e16dd.png 480w, https://caibb16.github.io/p/navila%E5%A4%8D%E7%8E%B0%E7%AC%94%E8%AE%B0/image2_hu_b30a74d5aab416f5.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Navila控制策略&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;237&#34;
		data-flex-basis=&#34;569px&#34;
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;视觉移动策略
&lt;ul&gt;
&lt;li&gt;该控制策略在Isaac Sim模拟器中使用Isaac Lab进行训练，然后直接部署到真实机器人上&lt;/li&gt;
&lt;li&gt;将VLM输出的可执行指令转换为固定的速度指令，例如将{前进，向左转，向右转，停止}转换为{0.5 m /s，π/6 rad/s， −π/6 rad/s ，0}并执行相应时间&lt;/li&gt;
&lt;li&gt;采用PPO算法训练控制策略，了解PPO算法可参考我的&lt;a class=&#34;link&#34; href=&#34;https://caibb16.github.io/p/reinforcement-learning/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;强化学习笔记&lt;/a&gt;。Critic的观察空间包含当前时间步 t 的本体感觉和速度指令，以及机器人周围的特权地形高度扫描，其中本体感觉数据包括机器人的线速度和角速度、方向、关节位置、关节速度以及之前的动作。Actor的观察空间排除了线速度，动作空间定义为期望的关节位置&lt;/li&gt;
&lt;li&gt;机器人配备了一个安装在其头部底座的 LiDAR 传感器，用于检测现实中的透明物体&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;实验复现评估部分&#34;&gt;实验复现(评估部分)
&lt;/h2&gt;&lt;h3 id=&#34;环境配置&#34;&gt;环境配置
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;创建模型评估的虚拟环境&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;conda create -n navila-eval &lt;span class=&#34;nv&#34;&gt;python&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;3.10
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;conda activate navila-eval  &lt;span class=&#34;c1&#34;&gt;# 后续pip安装均在该环境下进行&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;安装 Habitat-Sim and Lab(v0.1.7),参考&lt;a class=&#34;link&#34; href=&#34;https://github.com/jacobkrantz/VLN-CE?tab=readme-ov-file#setup&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;VLA-CE设置&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于Habitat-Sim(0.1.7)只支持python3.6~3.9，在3.10环境下需要采用源码安装&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 安装Habitat-Lab&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone --branch v0.1.7 https://github.com/facebookresearch/habitat-lab.git
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; habitat-lab
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# installs both habitat and habitat_baselines&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;python -m pip install -r requirements.txt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;python -m pip install -r habitat_baselines/rl/requirements.txt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;python -m pip install -r habitat_baselines/rl/ddppo/requirements.txt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;python setup.py develop --all
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;安装Habitat-sim(v0.1.7),参考&lt;a class=&#34;link&#34; href=&#34;https://github.com/facebookresearch/habitat-sim/blob/v0.1.7/BUILD_FROM_SOURCE.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方源码安装指南&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/facebookresearch/habitat-sim.git &lt;span class=&#34;c1&#34;&gt;#（默认就是v0.1.7）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; habitat-sim
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git submodule update --init --recursive
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git checkout v0.1.7
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git submodule update --init --recursive &lt;span class=&#34;c1&#34;&gt;#注意切换分支后可能导致部分submodule无效&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;python -m pip install -r requirements.txt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 如果出现路径问题编译不成功，可能因为之前编译过了，进入到habitat-sim目录删除build(rm -rf build)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;python -m pip install cmake
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get update &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get install -y --no-install-recommends &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;     libjpeg-dev libglm-dev libgl1-mesa-glx libegl1-mesa-dev mesa-utils xorg-dev freeglut3-dev
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 可能出现安装libgl1-mesa-glx不成功，可以尝试单独安装以下两个依赖&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# sudo apt-get install libgl1-mesa-dev&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# sudo apt-get install libegl1-mesa-dev&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;python -m pip install --upgrade pybind11
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 注意，编译要采用headless模式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;python setup.py install --headless --cmake-args&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;-DCMAKE_POLICY_VERSION_MINIMUM=3.5 -DCMAKE_CXX_STANDARD=11&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;编译时若遇到error: ‘uint16_t’ in namespace ‘std’ does not name a type; did you mean ‘wint_t’?报错,在编译时添加 cstdint 头文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;python setup.py install --headless --cmake-args=&amp;#34;-DCMAKE_POLICY_VERSION_MINIMUM=3.5 -DCMAKE_CXX_STANDARD=11 -DCMAKE_CXX_FLAGS=-include\ cstdint&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;解决 NumPy 兼容性问题&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; Navila
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;python evaluation/scripts/habitat_sim_autofix.py &lt;span class=&#34;c1&#34;&gt;# replace habitat_sim/utils/common.py&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;安装VLN-CE依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;python -m pip install -r evaluation/requirements.txt
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;安装VILA依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 安装 FlashAttention2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;python -m pip install https://github.com/Dao-AILab/flash-attention/releases/download/v2.5.8/flash_attn-2.5.8+cu122torch2.3cxx11abiFALSE-cp310-cp310-linux_x86_64.whl
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 安装 VILA (假设在项目根目录下)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;python -m pip install -e .
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;python -m pip install -e &lt;span class=&#34;s2&#34;&gt;&amp;#34;.[train]&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;python -m pip install -e &lt;span class=&#34;s2&#34;&gt;&amp;#34;.[eval]&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 安装 HF 的 Transformers&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;python -m pip install git+https://github.com/huggingface/transformers@v4.37.2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 替换部分包以兼容&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;site_pkg_path&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;python -c &lt;span class=&#34;s1&#34;&gt;&amp;#39;import site; print(site.getsitepackages()[0])&amp;#39;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cp -rv ./llava/train/transformers_replace/* &lt;span class=&#34;nv&#34;&gt;$site_pkg_path&lt;/span&gt;/transformers/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cp -rv ./llava/train/deepspeed_replace/* &lt;span class=&#34;nv&#34;&gt;$site_pkg_path&lt;/span&gt;/deepspeed/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;5.修复 WebDataset 版本以实现 VLN-CE 兼容性&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;python -m pip install &lt;span class=&#34;nv&#34;&gt;webdataset&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;0.1.103
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;数据集下载&#34;&gt;数据集下载
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;参考&lt;a class=&#34;link&#34; href=&#34;https://github.com/jacobkrantz/VLN-CE?tab=readme-ov-file#setup&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;VLA-CE&lt;/a&gt;下载R2R和RxR数据集，并解压到&lt;code&gt;evaluation/data&lt;/code&gt;路径&lt;/li&gt;
&lt;li&gt;下载Matterport3D数据集，可通过&lt;a class=&#34;link&#34; href=&#34;https://niessner.github.io/Matterport/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官网&lt;/a&gt;申请获取，也可参考&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_41204464/article/details/149549133&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;mp3D 数据集&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数据应具备如下结构：&lt;code&gt;evaluation/data&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;data/datasets
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├─ RxR_VLNCE_v0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|   ├─ train
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|   |    ├─ train_guide.json.gz
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|   |    ├─ ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|   ├─ val_unseen
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|   |    ├─ val_unseen_guide.json.gz
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|   |    ├─ ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|   ├─ ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├─ R2R_VLNCE_v1-3_preprocessed
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|   ├─ train
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|   |    ├─ train.json.gz
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|   |    ├─ ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|   ├─ val_unseen
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|   |    ├─ val_unseen.json.gz
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|   |    ├─ ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;data/scene_datasets
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├─ mp3d
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|   ├─ 17DRP5sb8fy
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|   |    ├─ 17DRP5sb8fy.glb
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|   |    ├─ ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|   ├─ ...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;评估运行&#34;&gt;评估运行
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;下载checkpoint&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从&lt;a class=&#34;link&#34; href=&#34;https://huggingface.co/a8cheng/navila-llama3-8b-8f&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;a8cheng/navila-llama3-8b-8f&lt;/a&gt;下载预训练模型，并解压到&lt;code&gt;evaluation/models/navila-llama3-8b-8f&lt;/code&gt;路径下,可通过以下命令下载：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 安装 huggingface_hub&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;python -m pip install huggingface_hub
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;创建下载脚本&lt;code&gt;download_huggingface.py&lt;/code&gt;并运行,脚本内容如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;from huggingface_hub import snapshot_download
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;local_dir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; snapshot_download&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nv&#34;&gt;repo_id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;a8cheng/navila-llama3-8b-8f&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nv&#34;&gt;local_dir&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;~/NaVILA/navila-llama3-8b-8f&amp;#34;&lt;/span&gt;,  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nv&#34;&gt;cache_dir&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;~/NaVILA/navila-llama3-8b-8f/cache&amp;#34;&lt;/span&gt;, &lt;span class=&#34;c1&#34;&gt;# 改成自己的项目路径&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nv&#34;&gt;token&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;hf_******&amp;#34;&lt;/span&gt;,     &lt;span class=&#34;c1&#34;&gt;#  这里填写你的 HuggingFace 访问token&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nv&#34;&gt;endpoint&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;https://hf-mirror.com&amp;#34;&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;# 如果需要走镜像&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;print&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;模型下载到本地路径:&amp;#34;&lt;/span&gt;, local_dir&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在r2r上运行评估&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# bash scripts/eval/r2r.sh CKPT_PATH NUM_CHUNKS CHUNK_START_IDX &amp;#34;GPU_IDS&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 单显卡&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;bash scripts/eval/r2r.sh /data/code/seu004/czd/NaVILA/navila-llama3-8b-8f &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 多显卡&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;bash scripts/eval/r2r.sh /data/code/seu004/czd/NaVILA/navila-llama3-8b-8f &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;2,3,4,5&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 检查所有Python评估进程&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ps aux &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep &lt;span class=&#34;s2&#34;&gt;&amp;#34;run.py.*navila&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 停止当前评估&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;pkill -9 -f &lt;span class=&#34;s2&#34;&gt;&amp;#34;run.py.*navila&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 完成评估后汇总并查看得分&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;python scripts/eval_jsons.py ./eval_out/navila-llama3-8b-8f/VLN-CE-v1/val_unseen NUM_CHUNKS
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;debug&#34;&gt;Debug
&lt;/h3&gt;&lt;p&gt;记录项目复现过程中遇到的一些问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务器网络问题&lt;br&gt;
复现该项目时还是初次使用服务器，服务器由于没有图形化界面，一些仿真没办法实时显示，且服务器访问国外的网站速度较慢，不像自己电脑那样可以直接搭梯子访问。不过可以通过让服务器端走本地代理的方式来解决：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;在本地电脑输入以下命令:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 本地端口号7897,需要查看自己的clash等代理软件的端口号,填写其他参数记得删去占位符&amp;lt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ssh -vvv -N -R 7897:localhost:7897 -p &amp;lt;远程服务器端口号&amp;gt; &amp;lt;username&amp;gt;@&amp;lt;server_ip&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;在服务器上设置环境变量&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 只在当前终端生效,将其写入~/.bashrc文件可以永久生效，但我没有那个权限&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;http_proxy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;http://localhost:7897&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;https_proxy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;http://localhost:7897&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这样服务器就可以访问外网了，克隆github项目、下载hugging_face模型等都可以顺利进行。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Matterport3D数据集加载问题&lt;br&gt;
mp3d数据及下载比较麻烦，使用官方给的脚本不知道为什么只会下载scans文件夹，这里面一般是深度、RGB图片等原始数据,评估过程其实是不需要的，真正需要的是task文件夹下的文件，但即使我使用&amp;ndash;task habitat后缀仍然没法下载task相关文件，目前没找到解决办法，我是直接去找师兄要了数据集，也可以去咸鱼上买现成的。&lt;br&gt;
最后的场景文件夹下应包括.glb等格式的文件。不同的场景有不同的ID，理论上评估预训练模型需要许多场景，但我实测先装一个ID为zsNo4HB9uLZ的场景就可以跑通评测，过程中有的episode发现没有的场景会直接跳过，后续可以慢慢补充其他场景再进行评估。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;实验结果&#34;&gt;实验结果
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;运行r2r.sh脚本后，终端会实时可视化VLM的action指令&lt;img src=&#34;https://caibb16.github.io/p/navila%E5%A4%8D%E7%8E%B0%E7%AC%94%E8%AE%B0/image3.png&#34;
	width=&#34;625&#34;
	height=&#34;344&#34;
	srcset=&#34;https://caibb16.github.io/p/navila%E5%A4%8D%E7%8E%B0%E7%AC%94%E8%AE%B0/image3_hu_ee3553dcbcb888f6.png 480w, https://caibb16.github.io/p/navila%E5%A4%8D%E7%8E%B0%E7%AC%94%E8%AE%B0/image3_hu_b7787f6723bc3561.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;终端显示&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;181&#34;
		data-flex-basis=&#34;436px&#34;
	
&gt;&lt;/li&gt;
&lt;li&gt;并会在&lt;code&gt;valuation/eval_out/navila-llama3-8b-8f/VLN-CE-v1/val_unseen/videos&lt;/code&gt;路径下生成大量评估视频，视频左下方为导航指令，视频名称中的spl是导航中常用的评估指标，基准值为1/0代表是否成功，再乘上一个最短路径与实际路径比值。&lt;br&gt;
每个视频是一个episode，会选取一个场景进行评估，解压R2R数据集下的val_unseen.json.gz文件后可以看到episodes总共有1838个，8张显卡大概要跑2～3小时，如果不查看最终分数的话不跑完也可以。&lt;/li&gt;
&lt;li&gt;其中一个 spl=1 的episode如下：&lt;br&gt;
&lt;video src=&#34;episode=53-ckpt=0-spl=1.00.mp4&#34; controls=&#34;controls&#34; width=&#34;700&#34;&gt;&lt;/video&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Reinforcement Learning</title>
        <link>https://caibb16.github.io/p/reinforcement-learning/</link>
        <pubDate>Sun, 21 Dec 2025 14:49:14 +0800</pubDate>
        
        <guid>https://caibb16.github.io/p/reinforcement-learning/</guid>
        <description>&lt;h2 id=&#34;什么是强化学习&#34;&gt;什么是强化学习
&lt;/h2&gt;&lt;p&gt;强化学习（Reinforcement Learning，RL）是一种机器学习范式，旨在训练智能体通过与环境交互来学习最佳行为策略，以最大化累积奖励。与监督学习不同，强化学习没有明确的输入输出对，而是通过试错和奖励信号来指导学习过程。&lt;/p&gt;
&lt;h2 id=&#34;强化学习的基本概念&#34;&gt;强化学习的基本概念
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;智能体（Agent）&lt;/strong&gt;：执行动作以与环境交互的实体。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;环境（Environment）&lt;/strong&gt;：智能体所处的外部系统，智能体通过与环境交互来获取状态和奖励。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;状态（State）&lt;/strong&gt;：环境在某一时刻的描述，智能体根据状态做出决策。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动作（Action）&lt;/strong&gt;：智能体在特定状态下可以执行的操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;奖励（Reward）&lt;/strong&gt;：智能体执行动作后从环境中获得的反馈信号，用于评估动作的好坏。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;策略（Policy）&lt;/strong&gt;：智能体在给定状态下选择动作的规则或函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;价值函数（Value Function）&lt;/strong&gt;：评估在某一状态下，智能体未来可能获得的累积奖励。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;马尔可夫决策过程&#34;&gt;马尔可夫决策过程
&lt;/h2&gt;&lt;p&gt;强化学习通常建模为马尔可夫决策过程（Markov Decision Process，MDP），包括状态空间、动作空间、转移概率和奖励函数。MDP假设未来状态仅依赖于当前状态和动作，而与过去状态无关。&lt;/p&gt;
&lt;h2 id=&#34;ppo算法简介&#34;&gt;PPO算法简介
&lt;/h2&gt;&lt;p&gt;Proximal Policy Optimization（PPO）是一种常用的强化学习算法，属于策略梯度方法。PPO通过限制策略更新的幅度，确保新策略不会偏离旧策略过远，从而提高训练的稳定性和效率。PPO通常使用剪切概率比（clipped probability ratio）来限制策略更新。&lt;/p&gt;
&lt;h3 id=&#34;基本架构&#34;&gt;基本架构
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;策略网络（Policy Network）&lt;/strong&gt;：用于输出在给定状态下选择各个动作的概率分布。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;价值网络（Value Network）&lt;/strong&gt;：用于估计在给定状态下的价值函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;训练过程&#34;&gt;训练过程
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;采样数据&lt;/strong&gt;：智能体与环境交互，策略网络根据当前状态 s 和自身策略，选择并执行动作 a，收集状态、动作、奖励和下一个状态的数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;计算优势函数&lt;/strong&gt;：使用价值网络估计状态的价值，并计算优势函数以评估动作的好坏。优势用于衡量在给定状态下选择某个动作相对于平均水平的好处，其计算方法通常是用动作价值函数减去状态价值函数。公式如下：
 &lt;center&gt;A(s, a) = Q(s, a) - V(s)&lt;/center&gt; 
 其中， A(s, a)是优势函数，Q(s, a)表示在状态 s 下采取动作 a 随后继续遵循策略π的价值，V(s) 表示在状态 s 下遵循策略π的价值。
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更新策略网络&lt;/strong&gt;：利用优势函数来更新自己的策略网络，使自己更倾向于选择能获得高评分的动作。同时使用剪切概率比限制策略更新的幅度，确保新策略不会偏离旧策略过远。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更新价值网络&lt;/strong&gt;：使用TD误差优化价值网络参数，TD误差可以衡量价值网络预测值与实际回报之间的差异。&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>java_study</title>
        <link>https://caibb16.github.io/p/java_study/</link>
        <pubDate>Fri, 05 Dec 2025 00:00:00 +0000</pubDate>
        
        <guid>https://caibb16.github.io/p/java_study/</guid>
        <description>&lt;h2 id=&#34;数据类型&#34;&gt;数据类型
&lt;/h2&gt;&lt;h3 id=&#34;基本数据类型数据值存储在自己空间&#34;&gt;基本数据类型：数据值存储在自己空间
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;整数类型：byte、short、int、long&lt;br&gt;
整数在计算机中以补码形式存在，最高位为符号位&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;byte 1字节&lt;br&gt;
short 2字节&lt;br&gt;
int  4字节&lt;br&gt;
long 8字节&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浮点类型：float、double&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符类型：char&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;布尔类型：boolean&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;引用数据类型数据值存储在堆中自己空间存储地址值&#34;&gt;引用数据类型：数据值存储在堆中，自己空间存储地址值
&lt;/h3&gt;&lt;p&gt;类、接口、数组&lt;/p&gt;
&lt;h3 id=&#34;类型转换&#34;&gt;类型转换
&lt;/h3&gt;&lt;p&gt;小范围转大范围：高位补0，符号位扩展&lt;br&gt;
大范围转小范围：直接截取低位&lt;/p&gt;
&lt;h2 id=&#34;switch语句&#34;&gt;switch语句
&lt;/h2&gt;&lt;p&gt;case穿透：执行case语句时，若未发现break，则顺序执行下一个case语句，直到发现break为止&lt;br&gt;
if和switch的各自应用场景：if一般用于对范围的判断，switch用于在有限个数据任选其一&lt;/p&gt;
&lt;h2 id=&#34;循环语句&#34;&gt;循环语句
&lt;/h2&gt;&lt;h3 id=&#34;for和while的对比&#34;&gt;for和while的对比
&lt;/h3&gt;&lt;p&gt;相同点：运行规则相同&lt;br&gt;
不同点：for循环一般用于知道循环次数或者循环范围，while循环一般用于不知道循环次数和范围，只知道循环的结束条件&lt;/p&gt;
&lt;h3 id=&#34;continue和break&#34;&gt;continue和break
&lt;/h3&gt;&lt;p&gt;continue：结束本次循环，进入下一次循环
break：结束整个循环&lt;/p&gt;
&lt;h2 id=&#34;数组&#34;&gt;数组
&lt;/h2&gt;&lt;h3 id=&#34;静态初始化指定初始化值&#34;&gt;静态初始化（指定初始化值）
&lt;/h3&gt;&lt;p&gt;数据类型[] 数组名 = {元素1, 元素2, 元素3&amp;hellip;  }&lt;/p&gt;
&lt;h3 id=&#34;动态初始化指定数组长度&#34;&gt;动态初始化（指定数组长度）
&lt;/h3&gt;&lt;p&gt;数据类型[] 数组名 = new 数据类型[数组长度];&lt;/p&gt;
&lt;h3 id=&#34;遍历数组&#34;&gt;遍历数组
&lt;/h3&gt;&lt;p&gt;for(数据类型 变量名 : 数组名){
//使用变量名进行操作
}&lt;/p&gt;
&lt;h2 id=&#34;方法&#34;&gt;方法
&lt;/h2&gt;&lt;h3 id=&#34;方法的定义&#34;&gt;方法的定义
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;我要干什么？——方法体&lt;/li&gt;
&lt;li&gt;我需要什么？——形参&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;方法的基本内存原理&#34;&gt;方法的基本内存原理
&lt;/h3&gt;&lt;p&gt;栈：方法调用时进栈，执行结束时出栈（先进后出）&lt;br&gt;
堆：创建对象（new）时进堆，存储引用数据类型的值&lt;/p&gt;
&lt;h3 id=&#34;基本数据类型和引用数据类型的存储&#34;&gt;基本数据类型和引用数据类型的存储
&lt;/h3&gt;&lt;p&gt;基本数据类型：数据值存储在自己的空间中（传递时传递数据）&lt;br&gt;
引用数据类型：数据值存储在堆中，自己空间中存储的是地址值（传递时传递地址）&lt;/p&gt;
&lt;h2 id=&#34;二维数组&#34;&gt;二维数组
&lt;/h2&gt;&lt;h3 id=&#34;初始化&#34;&gt;初始化
&lt;/h3&gt;&lt;p&gt;数据类型[ ][ ] 数组名 = new 数据类型[行数][列数];&lt;br&gt;
数据类型[ ][ ] 数组名 = { {元素1, 元素2}, {元素3, 元素4} }&lt;/p&gt;
&lt;h3 id=&#34;遍历&#34;&gt;遍历
&lt;/h3&gt;&lt;p&gt;外循环：遍历二维数组获取每一个一维数组 （数组名[ ]获取一维数组地址）&lt;br&gt;
内循环：遍历一维数组获取每一个元素 （数组名[ ][ ]同时获取一维数组地址和元素）&lt;/p&gt;
&lt;h2 id=&#34;面向对象&#34;&gt;面向对象
&lt;/h2&gt;&lt;h3 id=&#34;类和对象的关系&#34;&gt;类和对象的关系
&lt;/h3&gt;&lt;p&gt;类是对象的模板，对象是类的具体体现&lt;/p&gt;
&lt;h3 id=&#34;成员变量和局部变量&#34;&gt;成员变量和局部变量
&lt;/h3&gt;&lt;p&gt;成员变量：定义在类中，方法外，可以被类中的所有方法使用，默认初始化值&lt;br&gt;
局部变量：定义在方法中，只能被该方法使用，使用前必须初始化&lt;/p&gt;
&lt;h3 id=&#34;构造方法&#34;&gt;构造方法
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;方法名和类名相同&lt;/li&gt;
&lt;li&gt;没有返回值类型&lt;/li&gt;
&lt;li&gt;用于创建对象并初始化对象成员变量&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;方法重载&#34;&gt;方法重载
&lt;/h3&gt;&lt;p&gt;在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或参数类型不同即可&lt;/p&gt;
&lt;h3 id=&#34;就近原则和this关键字&#34;&gt;就近原则和this关键字
&lt;/h3&gt;&lt;p&gt;就近原则：在方法中使用变量时，优先使用局部变量，如果没有则使用成员变量&lt;br&gt;
this关键字的两种用法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;表示当前对象的引用，指向当前对象本身&lt;/li&gt;
&lt;li&gt;在构造方法中，this(形参列表)表示调用本类中的另一个构造方法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;this的内存原理：this存储在栈中，指向堆中的当前对象，代表方法调用者的地址值&lt;/p&gt;
&lt;h3 id=&#34;javabean类描述某类事物&#34;&gt;JavaBean类（描述某类事物）
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;类是公共的（public）&lt;/li&gt;
&lt;li&gt;有一个无参的公共构造方法&lt;/li&gt;
&lt;li&gt;成员变量私有化（private）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;对象的内存解析&#34;&gt;对象的内存解析
&lt;/h3&gt;&lt;p&gt;栈：存储局部变量和方法调用&lt;br&gt;
堆：存储对象实例和数组实例，对象和数组的地址值存储在栈中&lt;br&gt;
方法区：存储类信息、常量、静态变量、方法字节码&lt;/p&gt;
&lt;h3 id=&#34;static关键字&#34;&gt;static关键字
&lt;/h3&gt;&lt;h4 id=&#34;静态变量&#34;&gt;静态变量
&lt;/h4&gt;&lt;p&gt;特点：被类的所有对象共享，随着类的加载而加载，优先于对象存在&lt;br&gt;
调用方式：类名.静态变量名 或 对象名.静态变量名&lt;/p&gt;
&lt;h4 id=&#34;静态方法&#34;&gt;静态方法
&lt;/h4&gt;&lt;p&gt;特点：多用在测试类和工具类中&lt;br&gt;
调用方式：类名.静态方法名 或 对象名.静态方法名&lt;br&gt;
静态方法中不能使用非静态的成员变量和成员方法，非静态方法二者都可以使用，因为静态方法优先于对象存在，而非静态的成员变量和成员方法依赖于对象存在&lt;/p&gt;
&lt;h3 id=&#34;工具类&#34;&gt;工具类
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;提供静态方法，方便调用&lt;/li&gt;
&lt;li&gt;构造方法私有化，避免创建对象&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;集合&#34;&gt;集合
&lt;/h2&gt;&lt;h3 id=&#34;arraylist&#34;&gt;ArrayList
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;动态数组，长度可变&lt;/li&gt;
&lt;li&gt;存储有序的、可重复的数据&lt;/li&gt;
&lt;li&gt;底层使用Object[]数组存储数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;继承&#34;&gt;继承
&lt;/h2&gt;&lt;h3 id=&#34;继承的基本概念&#34;&gt;继承的基本概念
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;子类继承父类，子类拥有父类的属性和方法，可以访问父类的非私有成员&lt;/li&gt;
&lt;li&gt;继承方法：使用extends关键字实现继承&lt;/li&gt;
&lt;li&gt;继承特点：单继承、多层继承
&lt;blockquote&gt;
&lt;p&gt;单继承：Java中一个类只能有一个直接父类&lt;br&gt;
多层继承：子类继承父类，父类继承祖父类&lt;br&gt;
Object类：所有类都继承Object类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;继承中成员变量访问特点：
&lt;blockquote&gt;
&lt;p&gt;就进原则：子类对象访问成员变量时，优先访问局部变量，再访问子类自己的成员变量，再查找父类的成员变量，直到Object类为止，整个是一个向上的查找过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;super关键字&#34;&gt;super关键字
&lt;/h3&gt;&lt;p&gt;表示父类对象的引用，指向父类对象本身&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在子类构造方法中，super(形参列表)表示调用父类的构造方法&lt;br&gt;
super.成员变量名：访问父类的成员变量&lt;br&gt;
super.成员方法名(实参列表)：访问父类的成员方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;方法重写override&#34;&gt;方法重写（Override）
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;子类继承父类后，可以对父类的方法进行重新定义和实现&lt;/li&gt;
&lt;li&gt;重写方法的方法名、参数列表、返回值类型必须和父类被重写的方法相同&lt;/li&gt;
&lt;li&gt;重写方法的访问权限不能小于父类被重写的方法的访问权限&lt;/li&gt;
&lt;li&gt;父类被重写的方法不能是private、final、static修饰的&lt;/li&gt;
&lt;li&gt;重写方法中可以调用父类被重写的方法，使用super关键字实现&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;多态&#34;&gt;多态
&lt;/h3&gt;&lt;p&gt;定义：父类引用指向子类对象&lt;br&gt;
使用：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;创建对象时，使用父类创建子类对象；&lt;br&gt;
定义方法时，形参使用父类类型，可以传入所有子类对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;多态只能发生在继承关系中&lt;br&gt;
多态只能调用子类重写父类的方法，不能调用子类特有的方法&lt;br&gt;
多态的前提是有继承关系和方法重写&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;多态的体现：方法调用时，编译看左边，运行看右边;变量访问时，编译运行都看左边&lt;/p&gt;
&lt;h2 id=&#34;包&#34;&gt;包
&lt;/h2&gt;&lt;p&gt;包的作用：用于对类进行分类管理，避免类名冲突&lt;br&gt;
包的声明：package 包名;  声明在类的第一行&lt;br&gt;
包的导入：import 包名.类名; 或 import 包名.*;*表示导入包中所有类&lt;br&gt;
使用其他类的规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用同一个包中的类，不需要导包&lt;/li&gt;
&lt;li&gt;使用java.lang包中的类，不需要导包&lt;/li&gt;
&lt;li&gt;其他情况都需要导包&lt;/li&gt;
&lt;li&gt;使用两个包中的同名类，需要使用类的全限定名（包名.类名）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;final关键字&#34;&gt;final关键字
&lt;/h2&gt;&lt;h3 id=&#34;final修饰变量&#34;&gt;final修饰变量
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;基本数据类型：变量值不可改变&lt;/li&gt;
&lt;li&gt;引用数据类型：引用地址不可改变，但对象的内容可以改变&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;final修饰方法&#34;&gt;final修饰方法
&lt;/h3&gt;&lt;p&gt;表示该方法不能被重写&lt;/p&gt;
&lt;h3 id=&#34;final修饰类&#34;&gt;final修饰类
&lt;/h3&gt;&lt;p&gt;表示该类不能被继承&lt;/p&gt;
&lt;h2 id=&#34;静态代码块&#34;&gt;静态代码块
&lt;/h2&gt;&lt;p&gt;使用static关键字修饰，随着类的加载而执行，并且只执行一次&lt;br&gt;
作用：用于初始化类的信息&lt;/p&gt;
&lt;h2 id=&#34;抽象类和抽象方法&#34;&gt;抽象类和抽象方法
&lt;/h2&gt;&lt;h3 id=&#34;抽象方法&#34;&gt;抽象方法
&lt;/h3&gt;&lt;p&gt;父类中的抽象方法，提取子类的共性，没有方法体，用于被子类重写&lt;/p&gt;
&lt;h3 id=&#34;抽象类&#34;&gt;抽象类
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;抽象类不能实例化&lt;/li&gt;
&lt;li&gt;继承抽象类的子类必须重写父类中的所有抽象方法，除非子类也是抽象类&lt;/li&gt;
&lt;li&gt;抽象类可以有构造方法，用于子类创建对象时调用父类构造方法&lt;/li&gt;
&lt;li&gt;作用：强制让子类按照某种格式重写&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;接口&#34;&gt;接口
&lt;/h2&gt;&lt;h3 id=&#34;接口的定义&#34;&gt;接口的定义
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;使用interface关键字定义&lt;/li&gt;
&lt;li&gt;接口中只能定义常量和抽象方法&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;接口的作用&#34;&gt;接口的作用
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;规范类的行为&lt;/li&gt;
&lt;li&gt;实现多继承，接口可以被多个子类实现&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;接口中的成员&#34;&gt;接口中的成员
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;成员变量：只能是常量，默认修饰符public static final&lt;/li&gt;
&lt;li&gt;成员方法：只能是抽象方法，默认修饰符public abstract&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;接口的实现&#34;&gt;接口的实现
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;使用implements关键字实现接口&lt;/li&gt;
&lt;li&gt;格式：class 类名 implements 接口名1, 接口名2&amp;hellip;{}&lt;/li&gt;
&lt;li&gt;实现接口的类必须重写接口中的所有抽象方法，除非该类是抽象类&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;接口和类之间的关系&#34;&gt;接口和类之间的关系
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;类和类的关系：继承关系，只能单继承，不能多继承&lt;/li&gt;
&lt;li&gt;类和接口的关系：实现关系，可以单实现，也可以多实现，可以在继承一个类的同时实现多个接口&lt;/li&gt;
&lt;li&gt;接口和接口的关系：继承关系，可以单继承，也可以多继承&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;接口中新增的方法&#34;&gt;接口中新增的方法
&lt;/h3&gt;&lt;h4 id=&#34;默认方法&#34;&gt;默认方法
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;使用default关键字修饰，可以有方法体，实现类不强制重写&lt;/li&gt;
&lt;li&gt;实现类可以重写接口中的默认方法，需要去掉default关键字&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;静态方法-1&#34;&gt;静态方法
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;使用static关键字修饰，可以有方法体，实现类不能重写&lt;/li&gt;
&lt;li&gt;只能通过接口名调用接口中的静态方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;私有方法java-9及以上版本&#34;&gt;私有方法（Java 9及以上版本）
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;使用private关键字修饰&lt;/li&gt;
&lt;li&gt;只能在接口内部使用，不能被实现类使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;内部类&#34;&gt;内部类
&lt;/h2&gt;&lt;h3 id=&#34;成员内部类&#34;&gt;成员内部类
&lt;/h3&gt;&lt;h4 id=&#34;创建内部类对象&#34;&gt;创建内部类对象：
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;外部类名.内部类名 对象名 = new 外部类名().new 内部类名();&lt;/li&gt;
&lt;li&gt;在外部类的成员方法中创建内部类对象，外界通过外部类对象调用该方法获取内部类对象&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;内部类方法访问&#34;&gt;内部类方法访问
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;访问内部类成员：this.成员变量名 或 成员变量名&lt;/li&gt;
&lt;li&gt;访问外部类成员：外部类名.this.成员变量名&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;静态内部类&#34;&gt;静态内部类
&lt;/h3&gt;&lt;h4 id=&#34;创建静态内部类对象&#34;&gt;创建静态内部类对象
&lt;/h4&gt;&lt;p&gt;外部类名.内部类名 对象名 = new 外部类名.内部类名();&lt;/p&gt;
&lt;h4 id=&#34;静态内部类方法访问&#34;&gt;静态内部类方法访问
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;访问静态方法：外部类名.内部类名.静态方法名();&lt;/li&gt;
&lt;li&gt;访问非静态方法：创建对象后，通过对象调用;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;匿名内部类&#34;&gt;匿名内部类
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;定义：没有类名的内部类，必须继承一个类或实现一个接口，继承类或实现接口的同时创建对象&lt;/li&gt;
&lt;li&gt;作用：简化代码编写&lt;/li&gt;
&lt;li&gt;格式：new 父类名或接口名(){重写父类或接口的方法};&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;单列集合&#34;&gt;单列集合
&lt;/h2&gt;&lt;h3 id=&#34;collection顶层接口&#34;&gt;collection顶层接口
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;是单列集合的顶层接口，所有方法被list和set接口继承&lt;/li&gt;
&lt;li&gt;常用方法：add()、remove()、clear()、size()、isEmpty()、contains()、toArray()&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;list接口&#34;&gt;List接口
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;有序、可重复的集合&lt;/li&gt;
&lt;li&gt;常用实现类：ArrayList、LinkedList、Vector&lt;/li&gt;
&lt;li&gt;常用方法：add(index, element)、get(index)、set(index, element)、remove(index)、indexOf(element)、lastIndexOf(element)、subList(fromIndex, toIndex)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;set接口&#34;&gt;Set接口
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;无序、不可重复的集合&lt;/li&gt;
&lt;li&gt;常用实现类：HashSet、LinkedHashSet、TreeSet&lt;/li&gt;
&lt;li&gt;HashSet：基于哈希表实现，存储元素无序&lt;/li&gt;
&lt;li&gt;LinkedHashSet：基于哈希表和链表实现，存储元素有序&lt;/li&gt;
&lt;li&gt;TreeSet：基于红黑树实现，存储元素有序&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;集合遍历&#34;&gt;集合遍历
&lt;/h2&gt;&lt;h3 id=&#34;迭代器遍历&#34;&gt;迭代器遍历
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;用于遍历集合元素&lt;/li&gt;
&lt;li&gt;获取迭代器对象：Iterator&lt;String&gt; iterator = 集合对象.iterator();&lt;/li&gt;
&lt;li&gt;常用方法：hasNext()、next()、remove()&lt;br&gt;
hasNext() 判断当前指针是否有元素，next() 获取当前指向的元素并移动指针，remove() 删除当前元素&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;增强for遍历&#34;&gt;增强for遍历
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;格式：for(数据类型 变量名 : 集合对象){ //使用变量名进行操作 }&lt;/li&gt;
&lt;li&gt;适用于所有实现了Iterable接口的集合类&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;lamda表达式遍历&#34;&gt;lamda表达式遍历
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;格式：集合对象.forEach(变量名 -&amp;gt; { //使用变量名进行操作 });&lt;/li&gt;
&lt;li&gt;简化代码编写，提高可读性&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据结构&#34;&gt;数据结构
&lt;/h2&gt;&lt;h3 id=&#34;栈&#34;&gt;栈
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;先进后出（LIFO）的数据结构&lt;/li&gt;
&lt;li&gt;主要操作：push()入栈，pop()出栈，peek()查看栈顶元素&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;队列&#34;&gt;队列
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;先进先出（FIFO）的数据结构&lt;/li&gt;
&lt;li&gt;主要操作：offer()入队，poll()出队，peek()查看队头元素&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数组-1&#34;&gt;数组
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;由连续的内存空间组成的线性数据结构&lt;/li&gt;
&lt;li&gt;每个元素通过索引访问，查询操作高效，插入和删除操作较慢&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;链表&#34;&gt;链表
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;由节点组成的线性数据结构，每个节点是独立的对象，在内存中不连续&lt;/li&gt;
&lt;li&gt;每个节点包含数据值和下一个节点的地址&lt;/li&gt;
&lt;li&gt;特点：插入和删除操作高效，查询操作较慢&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;泛型&#34;&gt;泛型
&lt;/h2&gt;&lt;h3 id=&#34;集合中使用泛型&#34;&gt;集合中使用泛型
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;定义：在集合类中使用泛型，可以指定集合中存储元素的类型&lt;/li&gt;
&lt;li&gt;格式：集合类&amp;lt;数据类型&amp;gt; 对象名 = new 集合类&amp;lt;&amp;gt;();&lt;/li&gt;
&lt;li&gt;细节：
&lt;ul&gt;
&lt;li&gt;泛型只能是引用数据类型，不能是基本数据类型&lt;/li&gt;
&lt;li&gt;指定泛型的类型后，传递数据时可以传入该类型及其子类类型对象&lt;/li&gt;
&lt;li&gt;如果不写泛型，默认类型为Object&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;泛型类&#34;&gt;泛型类
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;定义：在类定义时使用泛型，可以指定类中成员变量和方法的参数类型&lt;/li&gt;
&lt;li&gt;格式：
&lt;ul&gt;
&lt;li&gt;定义类时：class 类名&lt;E&gt;{ //类体 }，E表示不确定的类型&lt;/li&gt;
&lt;li&gt;创建对象时：类名&amp;lt;数据类型&amp;gt; 对象名 = new 类名&amp;lt;&amp;gt;();&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;泛型方法&#34;&gt;泛型方法
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;定义：在方法定义时使用泛型，可以指定方法的参数类型和返回值类型&lt;/li&gt;
&lt;li&gt;格式：
&lt;ul&gt;
&lt;li&gt;定义方法时：&lt;E&gt; 返回值类型 方法名(E 参数名){ //方法体 }&lt;/li&gt;
&lt;li&gt;调用方法时：对象名.方法名(实参);&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;泛型接口&#34;&gt;泛型接口
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;定义：在接口定义时使用泛型，可以指定接口中方法的参数类型和返回值类型&lt;/li&gt;
&lt;li&gt;格式：
&lt;ul&gt;
&lt;li&gt;定义接口时：interface 接口名&lt;E&gt;{ //接口体 }&lt;/li&gt;
&lt;li&gt;实现接口的两种方式：
&lt;ul&gt;
&lt;li&gt;实现类给出具体的类型：class 类名 implements 接口名&amp;lt;数据类型&amp;gt;{ //类体 }&lt;/li&gt;
&lt;li&gt;实现类继续使用泛型：class 类名&lt;E&gt; implements 接口名&lt;E&gt;{ //类体 }&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;泛型通配符&#34;&gt;泛型通配符
&lt;/h3&gt;&lt;p&gt;定义：在使用泛型时，可以使用通配符?表示不确定的类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上限通配符：? extends 父类类型，表示可以使用父类类型及其子类类型&lt;/li&gt;
&lt;li&gt;下限通配符：? super 子类类型，表示可以使用子类类型及其父类类型&lt;/li&gt;
&lt;li&gt;无限制通配符：?，表示可以使用任何类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据结构树&#34;&gt;数据结构（树）
&lt;/h2&gt;&lt;h3 id=&#34;二叉树&#34;&gt;二叉树
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;定义：每个节点最多有两个子节点的树形数据结构&lt;/li&gt;
&lt;li&gt;特点：每个节点有一个左子节点和一个右子节点&lt;/li&gt;
&lt;li&gt;遍历方式：
&lt;ul&gt;
&lt;li&gt;前序遍历：先访问根节点，再访问左子树，最后访问右子树&lt;/li&gt;
&lt;li&gt;中序遍历：先访问左子树，再访问根节点，最后访问右子树&lt;/li&gt;
&lt;li&gt;后序遍历：先访问左子树，再访问右子树，最后访问根节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二叉搜索树&#34;&gt;二叉搜索树
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;定义：一种特殊的二叉树，满足左子节点小于根节点，右子节点大于根节点的性质&lt;/li&gt;
&lt;li&gt;特点：支持高效的查找、插入和删除操作&lt;/li&gt;
&lt;li&gt;应用：常用于实现动态集合&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;平衡二叉树&#34;&gt;平衡二叉树
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;定义：一种自平衡的二叉搜索树，保证任意节点的左右子树高度差不超过1&lt;/li&gt;
&lt;li&gt;特点：通过旋转操作保持平衡&lt;/li&gt;
&lt;li&gt;应用：常用于实现高效的查找、插入和删除操作&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;红黑树&#34;&gt;红黑树
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;定义：一种自平衡的二叉搜索树，每个节点有颜色属性（红色或黑色）&lt;/li&gt;
&lt;li&gt;特点：通过颜色属性和旋转操作&lt;/li&gt;
&lt;li&gt;应用：常用于实现关联数组和集合&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;set系列集合&#34;&gt;Set系列集合
&lt;/h2&gt;&lt;p&gt;特点：无序、不可重复、无索引&lt;/p&gt;
&lt;h3 id=&#34;hashset&#34;&gt;HashSet
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;底层数据结构：哈希表（数组+链表/红黑树）&lt;/li&gt;
&lt;li&gt;特点：无序、不可重复、查询效率高&lt;/li&gt;
&lt;li&gt;添加元素过程：
&lt;ul&gt;
&lt;li&gt;计算元素的哈希值，确定存储位置&lt;/li&gt;
&lt;li&gt;如果位置为空，直接存储&lt;/li&gt;
&lt;li&gt;如果位置不为空，使用equals()方法判断是否重复，重复则不添加，不重复则添加到链表或红黑树中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接口实现：
&lt;ul&gt;
&lt;li&gt;重写hashCode()和equals()方法（这两个方法属于Object类），确保元素唯一性;&lt;/li&gt;
&lt;li&gt;不同对象只要属性值相同，hashCode()返回相同的哈希值，equals()返回true&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;linkedhashset&#34;&gt;LinkedHashSet
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;底层数据结构：哈希表+双向链表（维护元素的插入顺序）&lt;/li&gt;
&lt;li&gt;特点：有序、不可重复、无索引&lt;/li&gt;
&lt;li&gt;接口实现：重写hashCode()和equals()方法，确保元素唯一性&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;treeset&#34;&gt;TreeSet
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;底层数据结构：红黑树&lt;/li&gt;
&lt;li&gt;特点：有序、不可重复、无索引&lt;/li&gt;
&lt;li&gt;添加元素过程：
&lt;ul&gt;
&lt;li&gt;使用compareTo()或compare()方法比较元素大小，确定存储位置&lt;/li&gt;
&lt;li&gt;按照大小顺序存储元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接口实现：
&lt;ul&gt;
&lt;li&gt;默认排序：集合中的元素实现Comparable接口，重写compareTo()方法，指定排序规则&lt;/li&gt;
&lt;li&gt;比较器排序：集合使用Comparator接口，重写compare()方法，指定排序规则&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;双列集合&#34;&gt;双列集合
&lt;/h2&gt;&lt;h3 id=&#34;map接口&#34;&gt;Map接口
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;双列集合的顶层接口，存储键值对（key-value）&lt;/li&gt;
&lt;li&gt;常用实现类：HashMap、LinkedHashMap、TreeMap&lt;/li&gt;
&lt;li&gt;常用方法：put(key, value)、get(key)、remove(key)、containsKey(key)、containsValue(value)、keySet()、values()、entrySet()&lt;/li&gt;
&lt;li&gt;遍历方法：
&lt;ul&gt;
&lt;li&gt;keySet()把键存储到Set集合中，遍历Set集合获取键，再通过键获取值&lt;/li&gt;
&lt;li&gt;EntrySet()把键值对存储到Set集合中，遍历Set集合用getKey()和getValue()方法获取每一个键值对，再通过键值对获取键和值&lt;/li&gt;
&lt;li&gt;Lambda表达式遍历：map.forEach((key, value) -&amp;gt; { //使用key和value进行操作 });&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;hashmap&#34;&gt;HashMap
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;底层数据结构：哈希表（数组+链表/红黑树）&lt;/li&gt;
&lt;li&gt;特点：无序、不可重复、无索引&lt;/li&gt;
&lt;li&gt;添加键值对过程：
&lt;ul&gt;
&lt;li&gt;计算键的哈希值，确定存储位置&lt;/li&gt;
&lt;li&gt;如果位置为空，直接存储键值对&lt;/li&gt;
&lt;li&gt;如果位置不为空，使用equals()方法判断键是否重复，重复则覆盖，不重复则添加到链表或红黑树中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;linkedhashmap&#34;&gt;LinkedHashMap
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;底层数据结构：哈希表+双向链表（维护键值对的插入顺序）&lt;/li&gt;
&lt;li&gt;特点：有序、不可重复、无索引&lt;/li&gt;
&lt;li&gt;添加键值对过程:
&lt;ul&gt;
&lt;li&gt;计算键的哈希值，确定存储位置&lt;/li&gt;
&lt;li&gt;如果位置为空，直接存储键值对，并在双向链表中维护插入顺序&lt;/li&gt;
&lt;li&gt;如果位置不为空，使用equals()方法判断键是否重复，重复则覆盖，不重复则添加到链表或红黑树中，并在双向链表中维护插入顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;treemap&#34;&gt;TreeMap
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;底层数据结构：红黑树&lt;/li&gt;
&lt;li&gt;特点：有序(对键进行排序)、不可重复、无索引&lt;/li&gt;
&lt;li&gt;添加键值对过程：
&lt;ul&gt;
&lt;li&gt;使用compareTo()或compare()方法比较键的大小，确定存储位置&lt;/li&gt;
&lt;li&gt;按照键的大小顺序存储键值对&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;不可变集合&#34;&gt;不可变集合
&lt;/h2&gt;&lt;p&gt;一旦创建后，集合的内容不能被修改（添加、删除、修改元素）&lt;/p&gt;
&lt;h3 id=&#34;创建不可变集合的方法&#34;&gt;创建不可变集合的方法
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;list.of(E&amp;hellip; elements)：创建不可变的List集合&lt;/li&gt;
&lt;li&gt;set.of(E&amp;hellip; elements)：创建不可变的Set集合，元素不能重复&lt;/li&gt;
&lt;li&gt;map.of(K k1, V v1, K k2, V v2, &amp;hellip;)：创建不可变的Map集合，键值对数量上限为10&lt;/li&gt;
&lt;li&gt;map.ofEntries(Map.Entry&amp;lt;? extends K, ? extends V&amp;gt;&amp;hellip; entries)：创建不可变的Map集合，键值对数量不限&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;stream流&#34;&gt;Stream流
&lt;/h2&gt;&lt;h3 id=&#34;使用&#34;&gt;使用
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;collection集合
&lt;ul&gt;
&lt;li&gt;集合对象.stream()：获取集合的Stream流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;map集合
&lt;ul&gt;
&lt;li&gt;需要先使用entrySet()将map转换为单列集合，再转换为Stream流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Arrays工具类
&lt;ul&gt;
&lt;li&gt;Arrays.stream(数组对象)：获取数组的Stream流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Stream接口
&lt;ul&gt;
&lt;li&gt;静态方法：of()、iterate()、generate()、concat()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;方法引用&#34;&gt;方法引用
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;定义：方法引用是Lambda表达式的一种简化形式，用于直接引用已有的方法，当做函数式接口中抽象方法的方法体&lt;/li&gt;
&lt;li&gt;lambda表达式格式：参数列表 -&amp;gt; 方法体&lt;/li&gt;
&lt;li&gt;方法引用格式：类名或对象名::方法名
&lt;ul&gt;
&lt;li&gt;引用静态方法：类名::静态方法名&lt;/li&gt;
&lt;li&gt;引用成员方法：对象名::成员方法名&lt;/li&gt;
&lt;li&gt;引用构造方法：类名::new&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;异常&#34;&gt;异常
&lt;/h2&gt;&lt;h3 id=&#34;异常的分类&#34;&gt;异常的分类
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;检查异常（编译时异常）：在编译阶段被检查的异常，必须处理，否则编译不通过，如IOException、SQLException&lt;/li&gt;
&lt;li&gt;非检查异常（运行时异常）：在运行阶段被检查的异常，不强制处理，如NullPointerException、ArrayIndexOutOfBoundsException&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;异常的处理&#34;&gt;异常的处理
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;try-catch语句
&lt;ul&gt;
&lt;li&gt;用在方法调用处，能让代码继续运行&lt;/li&gt;
&lt;li&gt;try块：包含可能抛出异常的代码，当执行到异常时，跳转到对应的catch块处理异常，不再执行try块中后续代码&lt;/li&gt;
&lt;li&gt;catch块：捕获并处理异常，可以有多个catch块处理不同类型的异常。如果catch没有捕获到异常，异常会继续向上抛出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;throws关键字
&lt;ul&gt;
&lt;li&gt;写在方法定义处，表示该方法可能抛出的异常类型，调用该方法时必须处理异常(编译异常一定要加throws)&lt;/li&gt;
&lt;li&gt;格式：返回值类型 方法名(参数列表) throws 异常类型1, 异常类型2&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;throw关键字
&lt;ul&gt;
&lt;li&gt;写在方法体中，表示抛出一个异常对象&lt;/li&gt;
&lt;li&gt;格式：throw new 异常类型(&amp;ldquo;异常信息&amp;rdquo;);&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自定义异常
&lt;ul&gt;
&lt;li&gt;手动定义异常类，继承Exception类或RuntimeException类，重写构造方法&lt;/li&gt;
&lt;li&gt;用于表示特定的异常情况，让报错信息更加见名知义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
    </channel>
</rss>
